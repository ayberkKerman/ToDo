{"ast":null,"code":"\"use strict\";\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst contentTypeRegexp = /^(.*?)\\/(.*?)([\\t ]*;.*)?$/;\nconst parameterValueRegexp = /^(.*?)=(.*)$/;\nconst quotedStringRegexp = /\"(?:[\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|(?:\\\\[\\t \\x21-\\x7E\\x80-\\xFF]))*\"/;\nconst qescRegExp = /\\\\([\\t \\x21-\\x7E\\x80-\\xFF])/g;\nconst quoteRegExp = /([\\\\\"])/g;\n\nfunction qstring(val) {\n  if (tokenRegexp.test(val)) {\n    return val;\n  }\n\n  return \"\\\"\" + val.replace(quoteRegExp, \"\\\\$1\") + \"\\\"\";\n}\n\nclass ContentType {\n  constructor(type, subtype, parameterList) {\n    this.type = type;\n    this.subtype = subtype;\n    this.parameterList = parameterList;\n  }\n\n  get(key) {\n    key = String(key).toLowerCase();\n    const param = this.parameterList.reverse().find(v => v.key === key);\n    return param ? param.value : undefined;\n  }\n\n  set(key, value) {\n    key = String(key).toLowerCase();\n    value = String(value);\n    this.parameterList = this.parameterList.filter(v => v.key !== key);\n    this.parameterList.push({\n      separator: \";\",\n      key,\n      value\n    });\n  }\n\n  isXML() {\n    return this.subtype === \"xml\" && (this.type === \"text\" || this.type === \"application\") || this.subtype.endsWith(\"+xml\");\n  }\n\n  isHTML() {\n    return this.subtype === \"html\" && this.type === \"text\";\n  }\n\n  isText() {\n    return this.type === \"text\";\n  }\n\n  toString() {\n    return this.type + \"/\" + this.subtype + this.parameterList.map(v => v.separator + (v.key ? v.key + \"=\" + qstring(v.value) : v.value)).join(\"\");\n  }\n\n}\n\nmodule.exports = function parseContentType(contentType) {\n  if (!contentType) {\n    return null;\n  }\n\n  const contentTypeMatch = contentTypeRegexp.exec(contentType);\n\n  if (contentTypeMatch) {\n    const type = contentTypeMatch[1];\n    const subtype = contentTypeMatch[2];\n    const parameters = contentTypeMatch[3];\n\n    if (tokenRegexp.test(type) && tokenRegexp.test(subtype)) {\n      const parameterPattern = /([\\t ]*;[\\t ]*)([^\\t ;]*)/g;\n      const parameterList = [];\n      let match;\n\n      while (match = parameterPattern.exec(parameters)) {\n        const separator = match[1];\n        const keyValue = parameterValueRegexp.exec(match[2]);\n        let key;\n        let value;\n\n        if (keyValue && tokenRegexp.test(keyValue[1])) {\n          key = keyValue[1];\n\n          if (quotedStringRegexp.test(keyValue[2])) {\n            value = keyValue[2].substr(1, keyValue[2].length - 2).replace(qescRegExp, \"$1\");\n          } else {\n            value = keyValue[2];\n          }\n        }\n\n        if (key) {\n          parameterList.push({\n            separator,\n            key: key.toLowerCase(),\n            value\n          });\n        } else {\n          parameterList.push({\n            separator,\n            value: match[2]\n          });\n        }\n      }\n\n      return new ContentType(type.toLowerCase(), subtype.toLowerCase(), parameterList);\n    }\n\n    return null;\n  }\n\n  return null;\n};","map":{"version":3,"names":["tokenRegexp","contentTypeRegexp","parameterValueRegexp","quotedStringRegexp","qescRegExp","quoteRegExp","qstring","val","test","replace","ContentType","constructor","type","subtype","parameterList","get","key","String","toLowerCase","param","reverse","find","v","value","undefined","set","filter","push","separator","isXML","endsWith","isHTML","isText","toString","map","join","module","exports","parseContentType","contentType","contentTypeMatch","exec","parameters","parameterPattern","match","keyValue","substr","length"],"sources":["C:/Users/ayber/node_modules/content-type-parser/lib/content-type-parser.js"],"sourcesContent":["\"use strict\";\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst contentTypeRegexp = /^(.*?)\\/(.*?)([\\t ]*;.*)?$/;\nconst parameterValueRegexp = /^(.*?)=(.*)$/;\nconst quotedStringRegexp = /\"(?:[\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|(?:\\\\[\\t \\x21-\\x7E\\x80-\\xFF]))*\"/;\nconst qescRegExp = /\\\\([\\t \\x21-\\x7E\\x80-\\xFF])/g;\nconst quoteRegExp = /([\\\\\"])/g;\n\nfunction qstring(val) {\n  if (tokenRegexp.test(val)) {\n    return val;\n  }\n  return \"\\\"\" + val.replace(quoteRegExp, \"\\\\$1\") + \"\\\"\";\n}\n\nclass ContentType {\n  constructor(type, subtype, parameterList) {\n    this.type = type;\n    this.subtype = subtype;\n    this.parameterList = parameterList;\n  }\n  get(key) {\n    key = String(key).toLowerCase();\n\n    const param = this.parameterList.reverse().find(v => v.key === key);\n    return param ? param.value : undefined;\n  }\n  set(key, value) {\n    key = String(key).toLowerCase();\n    value = String(value);\n\n    this.parameterList = this.parameterList.filter(v => v.key !== key);\n    this.parameterList.push({\n      separator: \";\",\n      key,\n      value\n    });\n  }\n  isXML() {\n    return (this.subtype === \"xml\" && (this.type === \"text\" || this.type === \"application\")) ||\n           this.subtype.endsWith(\"+xml\");\n  }\n  isHTML() {\n    return this.subtype === \"html\" && this.type === \"text\";\n  }\n  isText() {\n    return this.type === \"text\";\n  }\n  toString() {\n    return this.type + \"/\" + this.subtype +\n      this.parameterList.map(v => v.separator + (v.key ? v.key + \"=\" + qstring(v.value) : v.value))\n      .join(\"\");\n  }\n}\n\nmodule.exports = function parseContentType(contentType) {\n  if (!contentType) {\n    return null;\n  }\n  const contentTypeMatch = contentTypeRegexp.exec(contentType);\n  if (contentTypeMatch) {\n    const type = contentTypeMatch[1];\n    const subtype = contentTypeMatch[2];\n    const parameters = contentTypeMatch[3];\n    if (tokenRegexp.test(type) && tokenRegexp.test(subtype)) {\n      const parameterPattern = /([\\t ]*;[\\t ]*)([^\\t ;]*)/g;\n      const parameterList = [];\n      let match;\n      while ((match = parameterPattern.exec(parameters))) {\n        const separator = match[1];\n        const keyValue = parameterValueRegexp.exec(match[2]);\n        let key;\n        let value;\n        if (keyValue && tokenRegexp.test(keyValue[1])) {\n          key = keyValue[1];\n          if (quotedStringRegexp.test(keyValue[2])) {\n            value = keyValue[2]\n              .substr(1, keyValue[2].length - 2)\n              .replace(qescRegExp, \"$1\");\n          } else {\n            value = keyValue[2];\n          }\n        }\n        if (key) {\n          parameterList.push({\n            separator,\n            key: key.toLowerCase(),\n            value\n          });\n        } else {\n          parameterList.push({\n            separator,\n            value: match[2]\n          });\n        }\n      }\n      return new ContentType(type.toLowerCase(), subtype.toLowerCase(), parameterList);\n    }\n    return null;\n  }\n  return null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}