{"ast":null,"code":"var xpath = require('xpath'),\n    Dom = require('@xmldom/xmldom').DOMParser,\n    utils = require('./utils'),\n    c14n = require('./c14n-canonicalization'),\n    execC14n = require('./exclusive-canonicalization'),\n    EnvelopedSignature = require('./enveloped-signature').EnvelopedSignature,\n    crypto = require('crypto'),\n    fs = require('fs');\n\nexports.SignedXml = SignedXml;\nexports.FileKeyInfo = FileKeyInfo;\n/**\n * A key info provider implementation\n *\n */\n\nfunction FileKeyInfo(file) {\n  this.file = file;\n\n  this.getKeyInfo = function (key, prefix) {\n    prefix = prefix || '';\n    prefix = prefix ? prefix + ':' : prefix;\n    return \"<\" + prefix + \"X509Data></\" + prefix + \"X509Data>\";\n  };\n\n  this.getKey = function (keyInfo) {\n    return fs.readFileSync(this.file);\n  };\n}\n/**\n * Hash algorithm implementation\n *\n */\n\n\nfunction SHA1() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha1');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#sha1\";\n  };\n}\n\nfunction SHA256() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha256');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmlenc#sha256\";\n  };\n}\n\nfunction SHA512() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha512');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmlenc#sha512\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA1() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA1\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA1\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA256() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA256\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA256\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA512() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA512\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA512\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    if (callback) callback(null, res);\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\";\n  };\n}\n\nfunction HMACSHA1() {\n  this.verifySignature = function (str, key, signatureValue) {\n    var verifier = crypto.createHmac(\"SHA1\", key);\n    verifier.update(str);\n    var res = verifier.digest('base64');\n    return res === signatureValue;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\";\n  };\n\n  this.getSignature = function (signedInfo, signingKey) {\n    var verifier = crypto.createHmac(\"SHA1\", signingKey);\n    verifier.update(signedInfo);\n    var res = verifier.digest('base64');\n    return res;\n  };\n}\n/**\n * Extract ancestor namespaces in order to import it to root of document subset\n * which is being canonicalized for non-exclusive c14n.\n *\n * @param {object} doc - Usually a product from `new DOMParser().parseFromString()`\n * @param {string} docSubsetXpath - xpath query to get document subset being canonicalized\n * @param {object} namespaceResolver - xpath namespace resolver\n * @returns {Array} i.e. [{prefix: \"saml\", namespaceURI: \"urn:oasis:names:tc:SAML:2.0:assertion\"}]\n */\n\n\nfunction findAncestorNs(doc, docSubsetXpath, namespaceResolver) {\n  var docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);\n\n  if (!Array.isArray(docSubset) || docSubset.length < 1) {\n    return [];\n  } // Remove duplicate on ancestor namespace\n\n\n  var ancestorNs = collectAncestorNamespaces(docSubset[0]);\n  var ancestorNsWithoutDuplicate = [];\n\n  for (var i = 0; i < ancestorNs.length; i++) {\n    var notOnTheList = true;\n\n    for (var v in ancestorNsWithoutDuplicate) {\n      if (ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i].prefix) {\n        notOnTheList = false;\n        break;\n      }\n    }\n\n    if (notOnTheList) {\n      ancestorNsWithoutDuplicate.push(ancestorNs[i]);\n    }\n  } // Remove namespaces which are already declared in the subset with the same prefix\n\n\n  var returningNs = [];\n  var subsetAttributes = docSubset[0].attributes;\n\n  for (var j = 0; j < ancestorNsWithoutDuplicate.length; j++) {\n    var isUnique = true;\n\n    for (var k = 0; k < subsetAttributes.length; k++) {\n      var nodeName = subsetAttributes[k].nodeName;\n      if (nodeName.search(/^xmlns:/) === -1) continue;\n      var prefix = nodeName.replace(/^xmlns:/, \"\");\n\n      if (ancestorNsWithoutDuplicate[j].prefix === prefix) {\n        isUnique = false;\n        break;\n      }\n    }\n\n    if (isUnique) {\n      returningNs.push(ancestorNsWithoutDuplicate[j]);\n    }\n  }\n\n  return returningNs;\n}\n\nfunction collectAncestorNamespaces(node, nsArray) {\n  if (!nsArray) {\n    nsArray = [];\n  }\n\n  var parent = node.parentNode;\n\n  if (!parent) {\n    return nsArray;\n  }\n\n  if (parent.attributes && parent.attributes.length > 0) {\n    for (var i = 0; i < parent.attributes.length; i++) {\n      var attr = parent.attributes[i];\n\n      if (attr && attr.nodeName && attr.nodeName.search(/^xmlns:/) !== -1) {\n        nsArray.push({\n          prefix: attr.nodeName.replace(/^xmlns:/, \"\"),\n          namespaceURI: attr.nodeValue\n        });\n      }\n    }\n  }\n\n  return collectAncestorNamespaces(parent, nsArray);\n}\n/**\n* Xml signature implementation\n*\n* @param {string} idMode. Value of \"wssecurity\" will create/validate id's with the ws-security namespace\n* @param {object} options. Initial configurations\n*/\n\n\nfunction SignedXml(idMode, options) {\n  this.options = options || {};\n  this.idMode = idMode;\n  this.references = [];\n  this.id = 0;\n  this.signingKey = null;\n  this.signatureAlgorithm = this.options.signatureAlgorithm || \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  this.keyInfoProvider = null;\n  this.canonicalizationAlgorithm = this.options.canonicalizationAlgorithm || \"http://www.w3.org/2001/10/xml-exc-c14n#\";\n  this.signedXml = \"\";\n  this.signatureXml = \"\";\n  this.signatureNode = null;\n  this.signatureValue = \"\";\n  this.originalXmlWithIds = \"\";\n  this.validationErrors = [];\n  this.keyInfo = null;\n  this.idAttributes = ['Id', 'ID', 'id'];\n  if (this.options.idAttribute) this.idAttributes.splice(0, 0, this.options.idAttribute);\n  this.implicitTransforms = this.options.implicitTransforms || [];\n}\n\nSignedXml.CanonicalizationAlgorithms = {\n  'http://www.w3.org/TR/2001/REC-xml-c14n-20010315': c14n.C14nCanonicalization,\n  'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments': c14n.C14nCanonicalizationWithComments,\n  'http://www.w3.org/2001/10/xml-exc-c14n#': execC14n.ExclusiveCanonicalization,\n  'http://www.w3.org/2001/10/xml-exc-c14n#WithComments': execC14n.ExclusiveCanonicalizationWithComments,\n  'http://www.w3.org/2000/09/xmldsig#enveloped-signature': EnvelopedSignature\n};\nSignedXml.HashAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#sha1': SHA1,\n  'http://www.w3.org/2001/04/xmlenc#sha256': SHA256,\n  'http://www.w3.org/2001/04/xmlenc#sha512': SHA512\n};\nSignedXml.SignatureAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#rsa-sha1': RSASHA1,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256': RSASHA256,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512': RSASHA512 // Disabled by default due to key confusion concerns.\n  // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1\n\n};\n/**\n * Due to key-confusion issues, its risky to have both hmac\n * and digital signature algos enabled at the same time.\n * This enables HMAC and disables other signing algos.\n */\n\nSignedXml.enableHMAC = function () {\n  SignedXml.SignatureAlgorithms = {\n    'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1\n  };\n};\n\nSignedXml.defaultNsForPrefix = {\n  ds: 'http://www.w3.org/2000/09/xmldsig#'\n};\nSignedXml.findAncestorNs = findAncestorNs;\n\nSignedXml.prototype.checkSignature = function (xml, callback) {\n  if (callback != null && typeof callback !== 'function') {\n    throw new Error(\"Last paramater must be a callback function\");\n  }\n\n  this.validationErrors = [];\n  this.signedXml = xml;\n\n  if (!this.keyInfoProvider) {\n    var err = new Error(\"cannot validate signature since no key info resolver was provided\");\n\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err);\n      return;\n    }\n  }\n\n  this.signingKey = this.keyInfoProvider.getKey(this.keyInfo);\n\n  if (!this.signingKey) {\n    var err = new Error(\"key info provider could not resolve key info \" + this.keyInfo);\n\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err);\n      return;\n    }\n  }\n\n  var doc = new Dom().parseFromString(xml);\n\n  if (!this.validateReferences(doc)) {\n    if (!callback) {\n      return false;\n    } else {\n      callback(new Error('Could not validate references'));\n      return;\n    }\n  }\n\n  if (!callback) {\n    //Syncronous flow\n    if (!this.validateSignatureValue(doc)) {\n      return false;\n    }\n\n    return true;\n  } else {\n    //Asyncronous flow\n    this.validateSignatureValue(doc, function (err, isValidSignature) {\n      if (err) {\n        this.validationErrors.push(\"invalid signature: the signature value \" + this.signatureValue + \" is incorrect\");\n        callback(err);\n      } else {\n        callback(null, isValidSignature);\n      }\n    });\n  }\n};\n\nSignedXml.prototype.getCanonSignedInfoXml = function (doc) {\n  var signedInfo = utils.findChilds(this.signatureNode, \"SignedInfo\");\n  if (signedInfo.length == 0) throw new Error(\"could not find SignedInfo element in the message\");\n\n  if (this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" || this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\") {\n    if (!doc || typeof doc !== \"object\") {\n      throw new Error(\"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\");\n    }\n  }\n  /**\n   * Search for ancestor namespaces before canonicalization.\n   */\n\n\n  var ancestorNamespaces = [];\n  ancestorNamespaces = findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n  var c14nOptions = {\n    ancestorNamespaces: ancestorNamespaces\n  };\n  return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\n};\n\nSignedXml.prototype.getCanonReferenceXml = function (doc, ref, node) {\n  /**\n   * Search for ancestor namespaces before canonicalization.\n   */\n  if (Array.isArray(ref.transforms)) {\n    ref.ancestorNamespaces = findAncestorNs(doc, ref.xpath, this.namespaceResolver);\n  }\n\n  var c14nOptions = {\n    inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n    ancestorNamespaces: ref.ancestorNamespaces\n  };\n  return this.getCanonXml(ref.transforms, node, c14nOptions);\n};\n\nSignedXml.prototype.validateSignatureValue = function (doc, callback) {\n  var signedInfoCanon = this.getCanonSignedInfoXml(doc);\n  var signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  var res = signer.verifySignature(signedInfoCanon, this.signingKey, this.signatureValue, callback);\n  if (!res && !callback) this.validationErrors.push(\"invalid signature: the signature value \" + this.signatureValue + \" is incorrect\");\n  return res;\n};\n\nSignedXml.prototype.calculateSignatureValue = function (doc, callback) {\n  var signedInfoCanon = this.getCanonSignedInfoXml(doc);\n  var signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  this.signatureValue = signer.getSignature(signedInfoCanon, this.signingKey, callback);\n};\n\nSignedXml.prototype.findSignatureAlgorithm = function (name) {\n  var algo = SignedXml.SignatureAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"signature algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.findCanonicalizationAlgorithm = function (name) {\n  var algo = SignedXml.CanonicalizationAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"canonicalization algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.findHashAlgorithm = function (name) {\n  var algo = SignedXml.HashAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"hash algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.validateReferences = function (doc) {\n  for (var r in this.references) {\n    if (!this.references.hasOwnProperty(r)) continue;\n    var ref = this.references[r];\n    var uri = ref.uri[0] == \"#\" ? ref.uri.substring(1) : ref.uri;\n    var elem = [];\n\n    if (uri == \"\") {\n      elem = xpath.select(\"//*\", doc);\n    } else if (uri.indexOf(\"'\") != -1) {\n      // xpath injection\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\n    } else {\n      var elemXpath;\n      var num_elements_for_id = 0;\n\n      for (var index in this.idAttributes) {\n        if (!this.idAttributes.hasOwnProperty(index)) continue;\n        var tmp_elemXpath = \"//*[@*[local-name(.)='\" + this.idAttributes[index] + \"']='\" + uri + \"']\";\n        var tmp_elem = xpath.select(tmp_elemXpath, doc);\n        num_elements_for_id += tmp_elem.length;\n\n        if (tmp_elem.length > 0) {\n          elem = tmp_elem;\n          elemXpath = tmp_elemXpath;\n        }\n      }\n\n      if (num_elements_for_id > 1) {\n        throw new Error('Cannot validate a document which contains multiple elements with the ' + 'same value for the ID / Id / Id attributes, in order to prevent ' + 'signature wrapping attack.');\n      }\n\n      ref.xpath = elemXpath;\n    }\n\n    if (elem.length == 0) {\n      this.validationErrors.push(\"invalid signature: the signature refernces an element with uri \" + ref.uri + \" but could not find such element in the xml\");\n      return false;\n    }\n\n    var canonXml = this.getCanonReferenceXml(doc, ref, elem[0]);\n    var hash = this.findHashAlgorithm(ref.digestAlgorithm);\n    var digest = hash.getHash(canonXml);\n\n    if (!validateDigestValue(digest, ref.digestValue)) {\n      this.validationErrors.push(\"invalid signature: for uri \" + ref.uri + \" calculated digest is \" + digest + \" but the xml to validate supplies digest \" + ref.digestValue);\n      return false;\n    }\n  }\n\n  return true;\n};\n\nfunction validateDigestValue(digest, expectedDigest) {\n  var buffer, expectedBuffer;\n  var majorVersion = /^v(\\d+)/.exec(process.version)[1];\n\n  if (+majorVersion >= 6) {\n    buffer = Buffer.from(digest, 'base64');\n    expectedBuffer = Buffer.from(expectedDigest, 'base64');\n  } else {\n    // Compatibility with Node < 5.10.0\n    buffer = new Buffer(digest, 'base64');\n    expectedBuffer = new Buffer(expectedDigest, 'base64');\n  }\n\n  if (typeof buffer.equals === 'function') {\n    return buffer.equals(expectedBuffer);\n  } // Compatibility with Node < 0.11.13\n\n\n  if (buffer.length !== expectedBuffer.length) {\n    return false;\n  }\n\n  for (var i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== expectedBuffer[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nSignedXml.prototype.loadSignature = function (signatureNode) {\n  if (typeof signatureNode === 'string') {\n    this.signatureNode = signatureNode = new Dom().parseFromString(signatureNode);\n  } else {\n    this.signatureNode = signatureNode;\n  }\n\n  this.signatureXml = signatureNode.toString();\n  var nodes = xpath.select(\".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\", signatureNode);\n  if (nodes.length == 0) throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n  this.canonicalizationAlgorithm = nodes[0].value;\n  this.signatureAlgorithm = utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureMethod']/@Algorithm\").value;\n  this.references = [];\n  var references = xpath.select(\".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\", signatureNode);\n  if (references.length == 0) throw new Error(\"could not find any Reference elements\");\n\n  for (var i in references) {\n    if (!references.hasOwnProperty(i)) continue;\n    this.loadReference(references[i]);\n  }\n\n  this.signatureValue = utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureValue']/text()\").data.replace(/\\r?\\n/g, '');\n  this.keyInfo = xpath.select(\".//*[local-name(.)='KeyInfo']\", signatureNode);\n};\n/**\n * Load the reference xml node to a model\n *\n */\n\n\nSignedXml.prototype.loadReference = function (ref) {\n  var nodes = utils.findChilds(ref, \"DigestMethod\");\n  if (nodes.length == 0) throw new Error(\"could not find DigestMethod in reference \" + ref.toString());\n  var digestAlgoNode = nodes[0];\n  var attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n  if (!attr) throw new Error(\"could not find Algorithm attribute in node \" + digestAlgoNode.toString());\n  var digestAlgo = attr.value;\n  nodes = utils.findChilds(ref, \"DigestValue\");\n  if (nodes.length == 0) throw new Error(\"could not find DigestValue node in reference \" + ref.toString());\n\n  if (nodes[0].childNodes.length == 0 || !nodes[0].firstChild.data) {\n    throw new Error(\"could not find the value of DigestValue in \" + nodes[0].toString());\n  }\n\n  var digestValue = nodes[0].firstChild.data;\n  var transforms = [];\n  var inclusiveNamespacesPrefixList;\n  nodes = utils.findChilds(ref, \"Transforms\");\n\n  if (nodes.length != 0) {\n    var transformsNode = nodes[0];\n    var transformsAll = utils.findChilds(transformsNode, \"Transform\");\n\n    for (var t in transformsAll) {\n      if (!transformsAll.hasOwnProperty(t)) continue;\n      var trans = transformsAll[t];\n      transforms.push(utils.findAttr(trans, \"Algorithm\").value);\n    }\n\n    var inclusiveNamespaces = utils.findChilds(trans, \"InclusiveNamespaces\");\n\n    if (inclusiveNamespaces.length > 0) {\n      //Should really only be one prefix list, but maybe there's some circumstances where more than one to lets handle it\n      for (var i = 0; i < inclusiveNamespaces.length; i++) {\n        if (inclusiveNamespacesPrefixList) {\n          inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList + \" \" + inclusiveNamespaces[i].getAttribute('PrefixList');\n        } else {\n          inclusiveNamespacesPrefixList = inclusiveNamespaces[i].getAttribute('PrefixList');\n        }\n      }\n    }\n  }\n\n  var hasImplicitTransforms = Array.isArray(this.implicitTransforms) && this.implicitTransforms.length > 0;\n\n  if (hasImplicitTransforms) {\n    this.implicitTransforms.forEach(function (t) {\n      transforms.push(t);\n    });\n  }\n  /**\n   * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n   * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n   * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n   * See:\n   * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n   * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n   * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n   */\n\n\n  if (transforms.length === 0 || transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\") {\n    transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n  }\n\n  this.addReference(null, transforms, digestAlgo, utils.findAttr(ref, \"URI\").value, digestValue, inclusiveNamespacesPrefixList, false);\n};\n\nSignedXml.prototype.addReference = function (xpath, transforms, digestAlgorithm, uri, digestValue, inclusiveNamespacesPrefixList, isEmptyUri) {\n  this.references.push({\n    \"xpath\": xpath,\n    \"transforms\": transforms ? transforms : [\"http://www.w3.org/2001/10/xml-exc-c14n#\"],\n    \"digestAlgorithm\": digestAlgorithm ? digestAlgorithm : \"http://www.w3.org/2000/09/xmldsig#sha1\",\n    \"uri\": uri,\n    \"digestValue\": digestValue,\n    \"inclusiveNamespacesPrefixList\": inclusiveNamespacesPrefixList,\n    \"isEmptyUri\": isEmptyUri\n  });\n};\n/**\n * Compute the signature of the given xml (usign the already defined settings)\n *\n * Options:\n *\n * - `prefix` {String} Adds a prefix for the generated signature tags\n * - `attrs` {Object} A hash of attributes and values `attrName: value` to add to the signature root node\n * - `location` {{ reference: String, action: String }}\n * - `existingPrefixes` {Object} A hash of prefixes and namespaces `prefix: namespace` already in the xml\n *   An object with a `reference` key which should\n *   contain a XPath expression, an `action` key which\n *   should contain one of the following values:\n *   `append`, `prepend`, `before`, `after`\n *\n */\n\n\nSignedXml.prototype.computeSignature = function (xml, opts, callback) {\n  if (typeof opts === 'function' && callback == null) {\n    callback = opts;\n  }\n\n  if (callback != null && typeof callback !== 'function') {\n    throw new Error(\"Last paramater must be a callback function\");\n  }\n\n  var doc = new Dom().parseFromString(xml),\n      xmlNsAttr = \"xmlns\",\n      signatureAttrs = [],\n      location,\n      attrs,\n      prefix,\n      currentPrefix;\n  var validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n  opts = opts || {};\n  prefix = opts.prefix;\n  attrs = opts.attrs || {};\n  location = opts.location || {};\n  var existingPrefixes = opts.existingPrefixes || {};\n  this.namespaceResolver = {\n    lookupNamespaceURI: function (prefix) {\n      return existingPrefixes[prefix];\n    }\n  }; // defaults to the root node\n\n  location.reference = location.reference || \"/*\"; // defaults to append action\n\n  location.action = location.action || \"append\";\n\n  if (validActions.indexOf(location.action) === -1) {\n    var err = new Error(\"location.action option has an invalid action: \" + location.action + \", must be any of the following values: \" + validActions.join(\", \"));\n\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err, null);\n      return;\n    }\n  } // automatic insertion of `:`\n\n\n  if (prefix) {\n    xmlNsAttr += \":\" + prefix;\n    currentPrefix = prefix + \":\";\n  } else {\n    currentPrefix = \"\";\n  }\n\n  Object.keys(attrs).forEach(function (name) {\n    if (name !== \"xmlns\" && name !== xmlNsAttr) {\n      signatureAttrs.push(name + \"=\\\"\" + attrs[name] + \"\\\"\");\n    }\n  }); // add the xml namespace attribute\n\n  signatureAttrs.push(xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\"\");\n  var signatureXml = \"<\" + currentPrefix + \"Signature \" + signatureAttrs.join(\" \") + \">\";\n  signatureXml += this.createSignedInfo(doc, prefix);\n  signatureXml += this.getKeyInfo(prefix);\n  signatureXml += \"</\" + currentPrefix + \"Signature>\";\n  this.originalXmlWithIds = doc.toString();\n  var existingPrefixesString = \"\";\n  Object.keys(existingPrefixes).forEach(function (key) {\n    existingPrefixesString += \"xmlns:\" + key + '=\"' + existingPrefixes[key] + '\" ';\n  }); // A trick to remove the namespaces that already exist in the xml\n  // This only works if the prefix and namespace match with those in te xml\n\n  var dummySignatureWrapper = \"<Dummy \" + existingPrefixesString + \">\" + signatureXml + \"</Dummy>\";\n  var xml = new Dom().parseFromString(dummySignatureWrapper);\n  var signatureDoc = xml.documentElement.firstChild;\n  var referenceNode = xpath.select(location.reference, doc);\n\n  if (!referenceNode || referenceNode.length === 0) {\n    var err = new Error(\"the following xpath cannot be used because it was not found: \" + location.reference);\n\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err, null);\n      return;\n    }\n  }\n\n  referenceNode = referenceNode[0];\n\n  if (location.action === \"append\") {\n    referenceNode.appendChild(signatureDoc);\n  } else if (location.action === \"prepend\") {\n    referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n  } else if (location.action === \"before\") {\n    referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n  } else if (location.action === \"after\") {\n    referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n  }\n\n  this.signatureNode = signatureDoc;\n  var signedInfoNode = utils.findChilds(this.signatureNode, \"SignedInfo\");\n\n  if (signedInfoNode.length == 0) {\n    var err = new Error(\"could not find SignedInfo element in the message\");\n\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err);\n      return;\n    }\n  }\n\n  signedInfoNode = signedInfoNode[0];\n\n  if (!callback) {\n    //Synchronous flow\n    this.calculateSignatureValue(doc);\n    signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n    this.signatureXml = signatureDoc.toString();\n    this.signedXml = doc.toString();\n  } else {\n    var self = this; //Asynchronous flow\n\n    this.calculateSignatureValue(doc, function (err, signature) {\n      if (err) {\n        callback(err);\n      } else {\n        self.signatureValue = signature;\n        signatureDoc.insertBefore(self.createSignature(prefix), signedInfoNode.nextSibling);\n        self.signatureXml = signatureDoc.toString();\n        self.signedXml = doc.toString();\n        callback(null, self);\n      }\n    });\n  }\n};\n\nSignedXml.prototype.getKeyInfo = function (prefix) {\n  var res = \"\";\n  var currentPrefix;\n  currentPrefix = prefix || '';\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix;\n\n  if (this.keyInfoProvider) {\n    res += \"<\" + currentPrefix + \"KeyInfo>\";\n    res += this.keyInfoProvider.getKeyInfo(this.signingKey, prefix);\n    res += \"</\" + currentPrefix + \"KeyInfo>\";\n  }\n\n  return res;\n};\n/**\n * Generate the Reference nodes (as part of the signature process)\n *\n */\n\n\nSignedXml.prototype.createReferences = function (doc, prefix) {\n  var res = \"\";\n  prefix = prefix || '';\n  prefix = prefix ? prefix + ':' : prefix;\n\n  for (var n in this.references) {\n    if (!this.references.hasOwnProperty(n)) continue;\n    var ref = this.references[n],\n        nodes = xpath.selectWithResolver(ref.xpath, doc, this.namespaceResolver);\n\n    if (nodes.length == 0) {\n      throw new Error('the following xpath cannot be signed because it was not found: ' + ref.xpath);\n    }\n\n    for (var h in nodes) {\n      if (!nodes.hasOwnProperty(h)) continue;\n      var node = nodes[h];\n\n      if (ref.isEmptyUri) {\n        res += \"<\" + prefix + \"Reference URI=\\\"\\\">\";\n      } else {\n        var id = this.ensureHasId(node);\n        ref.uri = id;\n        res += \"<\" + prefix + \"Reference URI=\\\"#\" + id + \"\\\">\";\n      }\n\n      res += \"<\" + prefix + \"Transforms>\";\n\n      for (var t in ref.transforms) {\n        if (!ref.transforms.hasOwnProperty(t)) continue;\n        var trans = ref.transforms[t];\n        var transform = this.findCanonicalizationAlgorithm(trans);\n        res += \"<\" + prefix + \"Transform Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\";\n      }\n\n      var canonXml = this.getCanonReferenceXml(doc, ref, node);\n      var digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n      res += \"</\" + prefix + \"Transforms>\" + \"<\" + prefix + \"DigestMethod Algorithm=\\\"\" + digestAlgorithm.getAlgorithmName() + \"\\\" />\" + \"<\" + prefix + \"DigestValue>\" + digestAlgorithm.getHash(canonXml) + \"</\" + prefix + \"DigestValue>\" + \"</\" + prefix + \"Reference>\";\n    }\n  }\n\n  return res;\n};\n\nSignedXml.prototype.getCanonXml = function (transforms, node, options) {\n  options = options || {};\n  options.defaultNsForPrefix = options.defaultNsForPrefix || SignedXml.defaultNsForPrefix;\n  options.signatureNode = this.signatureNode;\n  var canonXml = node.cloneNode(true); // Deep clone\n\n  for (var t in transforms) {\n    if (!transforms.hasOwnProperty(t)) continue;\n    var transform = this.findCanonicalizationAlgorithm(transforms[t]);\n    canonXml = transform.process(canonXml, options); //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n    //This eitehr needs to be more explicit in the API, or all should return the same.\n    //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would inccorectly minimize empty tags\n    //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n    //enveloped transformation returns Node since if it would return String consider this case:\n    //<x xmlns:p='ns'><p:y/></x>\n    //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n  }\n\n  return canonXml.toString();\n};\n/**\n * Ensure an element has Id attribute. If not create it with unique value.\n * Work with both normal and wssecurity Id flavour\n */\n\n\nSignedXml.prototype.ensureHasId = function (node) {\n  var attr;\n\n  if (this.idMode == \"wssecurity\") {\n    attr = utils.findAttr(node, \"Id\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n  } else {\n    for (var index in this.idAttributes) {\n      if (!this.idAttributes.hasOwnProperty(index)) continue;\n      attr = utils.findAttr(node, this.idAttributes[index], null);\n      if (attr) break;\n    }\n  }\n\n  if (attr) return attr.value; //add the attribute\n\n  var id = \"_\" + this.id++;\n\n  if (this.idMode == \"wssecurity\") {\n    node.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:wsu\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n    node.setAttributeNS(\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\", \"wsu:Id\", id);\n  } else {\n    node.setAttribute(\"Id\", id);\n  }\n\n  return id;\n};\n/**\n * Create the SignedInfo element\n *\n */\n\n\nSignedXml.prototype.createSignedInfo = function (doc, prefix) {\n  var transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n  var algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  var currentPrefix;\n  currentPrefix = prefix || '';\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix;\n  var res = \"<\" + currentPrefix + \"SignedInfo>\";\n  res += \"<\" + currentPrefix + \"CanonicalizationMethod Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\" + \"<\" + currentPrefix + \"SignatureMethod Algorithm=\\\"\" + algo.getAlgorithmName() + \"\\\" />\";\n  res += this.createReferences(doc, prefix);\n  res += \"</\" + currentPrefix + \"SignedInfo>\";\n  return res;\n};\n/**\n * Create the Signature element\n *\n */\n\n\nSignedXml.prototype.createSignature = function (prefix) {\n  var xmlNsAttr = 'xmlns';\n\n  if (prefix) {\n    xmlNsAttr += ':' + prefix;\n    prefix += ':';\n  } else {\n    prefix = '';\n  }\n\n  var signatureValueXml = \"<\" + prefix + \"SignatureValue>\" + this.signatureValue + \"</\" + prefix + \"SignatureValue>\"; //the canonicalization requires to get a valid xml node.\n  //we need to wrap the info in a dummy signature since it contains the default namespace.\n\n  var dummySignatureWrapper = \"<\" + prefix + \"Signature \" + xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\">\" + signatureValueXml + \"</\" + prefix + \"Signature>\";\n  var doc = new Dom().parseFromString(dummySignatureWrapper);\n  return doc.documentElement.firstChild;\n};\n\nSignedXml.prototype.getSignatureXml = function () {\n  return this.signatureXml;\n};\n\nSignedXml.prototype.getOriginalXmlWithIds = function () {\n  return this.originalXmlWithIds;\n};\n\nSignedXml.prototype.getSignedXml = function () {\n  return this.signedXml;\n};","map":{"version":3,"names":["xpath","require","Dom","DOMParser","utils","c14n","execC14n","EnvelopedSignature","crypto","fs","exports","SignedXml","FileKeyInfo","file","getKeyInfo","key","prefix","getKey","keyInfo","readFileSync","SHA1","getHash","xml","shasum","createHash","update","res","digest","getAlgorithmName","SHA256","SHA512","RSASHA1","getSignature","signedInfo","signingKey","callback","signer","createSign","sign","verifySignature","str","signatureValue","verifier","createVerify","verify","RSASHA256","RSASHA512","HMACSHA1","createHmac","findAncestorNs","doc","docSubsetXpath","namespaceResolver","docSubset","selectWithResolver","Array","isArray","length","ancestorNs","collectAncestorNamespaces","ancestorNsWithoutDuplicate","i","notOnTheList","v","push","returningNs","subsetAttributes","attributes","j","isUnique","k","nodeName","search","replace","node","nsArray","parent","parentNode","attr","namespaceURI","nodeValue","idMode","options","references","id","signatureAlgorithm","keyInfoProvider","canonicalizationAlgorithm","signedXml","signatureXml","signatureNode","originalXmlWithIds","validationErrors","idAttributes","idAttribute","splice","implicitTransforms","CanonicalizationAlgorithms","C14nCanonicalization","C14nCanonicalizationWithComments","ExclusiveCanonicalization","ExclusiveCanonicalizationWithComments","HashAlgorithms","SignatureAlgorithms","enableHMAC","defaultNsForPrefix","ds","prototype","checkSignature","Error","err","parseFromString","validateReferences","validateSignatureValue","isValidSignature","getCanonSignedInfoXml","findChilds","ancestorNamespaces","c14nOptions","getCanonXml","getCanonReferenceXml","ref","transforms","inclusiveNamespacesPrefixList","signedInfoCanon","findSignatureAlgorithm","calculateSignatureValue","name","algo","findCanonicalizationAlgorithm","findHashAlgorithm","r","hasOwnProperty","uri","substring","elem","select","indexOf","elemXpath","num_elements_for_id","index","tmp_elemXpath","tmp_elem","canonXml","hash","digestAlgorithm","validateDigestValue","digestValue","expectedDigest","buffer","expectedBuffer","majorVersion","exec","process","version","Buffer","from","equals","loadSignature","toString","nodes","value","findFirst","loadReference","data","digestAlgoNode","findAttr","digestAlgo","childNodes","firstChild","transformsNode","transformsAll","t","trans","inclusiveNamespaces","getAttribute","hasImplicitTransforms","forEach","addReference","isEmptyUri","computeSignature","opts","xmlNsAttr","signatureAttrs","location","attrs","currentPrefix","validActions","existingPrefixes","lookupNamespaceURI","reference","action","join","Object","keys","createSignedInfo","existingPrefixesString","dummySignatureWrapper","signatureDoc","documentElement","referenceNode","appendChild","insertBefore","nextSibling","signedInfoNode","createSignature","self","signature","createReferences","n","h","ensureHasId","transform","cloneNode","setAttributeNS","setAttribute","signatureValueXml","getSignatureXml","getOriginalXmlWithIds","getSignedXml"],"sources":["C:/Users/ayber/node_modules/xml-crypto/lib/signed-xml.js"],"sourcesContent":["var xpath = require('xpath')\n  , Dom = require('@xmldom/xmldom').DOMParser\n  , utils = require('./utils')\n  , c14n = require('./c14n-canonicalization')\n  , execC14n = require('./exclusive-canonicalization')\n  , EnvelopedSignature = require('./enveloped-signature').EnvelopedSignature\n  , crypto = require('crypto')\n  , fs = require('fs')\n\nexports.SignedXml = SignedXml\nexports.FileKeyInfo = FileKeyInfo\n\n/**\n * A key info provider implementation\n *\n */\nfunction FileKeyInfo(file) {\n  this.file = file\n\n  this.getKeyInfo = function(key, prefix) {\n    prefix = prefix || ''\n    prefix = prefix ? prefix + ':' : prefix\n    return \"<\" + prefix + \"X509Data></\" + prefix + \"X509Data>\"\n  }\n\n  this.getKey = function(keyInfo) {\n    return fs.readFileSync(this.file)\n  }\n}\n\n/**\n * Hash algorithm implementation\n *\n */\nfunction SHA1() {\n\n  this.getHash = function(xml) {\n    var shasum = crypto.createHash('sha1')\n    shasum.update(xml, 'utf8')\n    var res = shasum.digest('base64')\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2000/09/xmldsig#sha1\"\n  }\n}\n\nfunction SHA256() {\n\n  this.getHash = function(xml) {\n    var shasum = crypto.createHash('sha256')\n    shasum.update(xml, 'utf8')\n    var res = shasum.digest('base64')\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2001/04/xmlenc#sha256\"\n  }\n}\n\nfunction SHA512() {\n\n  this.getHash = function(xml) {\n    var shasum = crypto.createHash('sha512')\n    shasum.update(xml, 'utf8')\n    var res = shasum.digest('base64')\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2001/04/xmlenc#sha512\"\n  }\n}\n\n\n/**\n * Signature algorithm implementation\n *\n */\nfunction RSASHA1() {\n\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function(signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA1\")\n    signer.update(signedInfo)\n    var res = signer.sign(signingKey, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n  this.verifySignature = function(str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA1\")\n    verifier.update(str)\n    var res = verifier.verify(key, signatureValue, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"\n  }\n\n}\n\n\n/**\n * Signature algorithm implementation\n *\n */\nfunction RSASHA256() {\n\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function(signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA256\")\n    signer.update(signedInfo)\n    var res = signer.sign(signingKey, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n  this.verifySignature = function(str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA256\")\n    verifier.update(str)\n    var res = verifier.verify(key, signatureValue, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\n  }\n\n}\n\n/**\n * Signature algorithm implementation\n *\n */\nfunction RSASHA512() {\n\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function(signedInfo, signingKey, callback) {\n    var signer = crypto.createSign(\"RSA-SHA512\")\n    signer.update(signedInfo)\n    var res = signer.sign(signingKey, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n  this.verifySignature = function(str, key, signatureValue, callback) {\n    var verifier = crypto.createVerify(\"RSA-SHA512\")\n    verifier.update(str)\n    var res = verifier.verify(key, signatureValue, 'base64')\n    if (callback) callback(null, res)\n    return res\n  }\n\n  this.getAlgorithmName = function() {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"\n  }\n}\n\nfunction HMACSHA1() {\n    this.verifySignature = function(str, key, signatureValue) {\n        var verifier = crypto.createHmac(\"SHA1\", key);\n        verifier.update(str);\n        var res = verifier.digest('base64');\n        return res === signatureValue;\n    };\n\n    this.getAlgorithmName = function() {\n        return \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\";\n    };\n\n    this.getSignature = function(signedInfo, signingKey) {\n        var verifier = crypto.createHmac(\"SHA1\", signingKey);\n        verifier.update(signedInfo);\n        var res = verifier.digest('base64');\n        return res;\n    };\n}\n\n\n\n/**\n * Extract ancestor namespaces in order to import it to root of document subset\n * which is being canonicalized for non-exclusive c14n.\n *\n * @param {object} doc - Usually a product from `new DOMParser().parseFromString()`\n * @param {string} docSubsetXpath - xpath query to get document subset being canonicalized\n * @param {object} namespaceResolver - xpath namespace resolver\n * @returns {Array} i.e. [{prefix: \"saml\", namespaceURI: \"urn:oasis:names:tc:SAML:2.0:assertion\"}]\n */\nfunction findAncestorNs(doc, docSubsetXpath, namespaceResolver){\n  var docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);\n  \n  if(!Array.isArray(docSubset) || docSubset.length < 1){\n    return [];\n  }\n  \n  // Remove duplicate on ancestor namespace\n  var ancestorNs = collectAncestorNamespaces(docSubset[0]);\n  var ancestorNsWithoutDuplicate = [];\n  for(var i=0;i<ancestorNs.length;i++){\n    var notOnTheList = true;\n    for(var v in ancestorNsWithoutDuplicate){\n      if(ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i].prefix){\n        notOnTheList = false;\n        break;\n      }\n    }\n    \n    if(notOnTheList){\n      ancestorNsWithoutDuplicate.push(ancestorNs[i]);\n    }\n  }\n  \n  // Remove namespaces which are already declared in the subset with the same prefix\n  var returningNs = [];\n  var subsetAttributes = docSubset[0].attributes;\n  for(var j=0;j<ancestorNsWithoutDuplicate.length;j++){\n    var isUnique = true;\n    for(var k=0;k<subsetAttributes.length;k++){\n      var nodeName = subsetAttributes[k].nodeName;\n      if(nodeName.search(/^xmlns:/) === -1) continue;\n      var prefix = nodeName.replace(/^xmlns:/, \"\");\n      if(ancestorNsWithoutDuplicate[j].prefix === prefix){\n        isUnique = false;\n        break;\n      }\n    }\n  \n    if(isUnique){\n      returningNs.push(ancestorNsWithoutDuplicate[j]);\n    }\n  }\n  \n  return returningNs;\n}\n\n\n\nfunction collectAncestorNamespaces(node, nsArray){\n  if(!nsArray){\n    nsArray = [];\n  }\n  \n  var parent = node.parentNode;\n  \n  if(!parent){\n    return nsArray;\n  }\n  \n  if(parent.attributes && parent.attributes.length > 0){\n    for(var i=0;i<parent.attributes.length;i++){\n      var attr = parent.attributes[i];\n      if(attr && attr.nodeName && attr.nodeName.search(/^xmlns:/) !== -1){\n        nsArray.push({prefix: attr.nodeName.replace(/^xmlns:/, \"\"), namespaceURI: attr.nodeValue})\n      }\n    }\n  }\n  \n  return collectAncestorNamespaces(parent, nsArray);\n}\n\n/**\n* Xml signature implementation\n*\n* @param {string} idMode. Value of \"wssecurity\" will create/validate id's with the ws-security namespace\n* @param {object} options. Initial configurations\n*/\nfunction SignedXml(idMode, options) {\n  this.options = options || {};\n  this.idMode = idMode\n  this.references = []\n  this.id = 0\n  this.signingKey = null\n  this.signatureAlgorithm = this.options.signatureAlgorithm || \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  this.keyInfoProvider = null\n  this.canonicalizationAlgorithm = this.options.canonicalizationAlgorithm || \"http://www.w3.org/2001/10/xml-exc-c14n#\"\n  this.signedXml = \"\"\n  this.signatureXml = \"\"\n  this.signatureNode = null\n  this.signatureValue = \"\"\n  this.originalXmlWithIds = \"\"\n  this.validationErrors = []\n  this.keyInfo = null\n  this.idAttributes = [ 'Id', 'ID', 'id' ];\n  if (this.options.idAttribute) this.idAttributes.splice(0, 0, this.options.idAttribute);\n  this.implicitTransforms = this.options.implicitTransforms || [];\n}\n\nSignedXml.CanonicalizationAlgorithms = {\n  'http://www.w3.org/TR/2001/REC-xml-c14n-20010315': c14n.C14nCanonicalization,\n  'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments': c14n.C14nCanonicalizationWithComments,\n  'http://www.w3.org/2001/10/xml-exc-c14n#': execC14n.ExclusiveCanonicalization,\n  'http://www.w3.org/2001/10/xml-exc-c14n#WithComments': execC14n.ExclusiveCanonicalizationWithComments,\n  'http://www.w3.org/2000/09/xmldsig#enveloped-signature': EnvelopedSignature\n}\n\nSignedXml.HashAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#sha1': SHA1,\n  'http://www.w3.org/2001/04/xmlenc#sha256': SHA256,\n  'http://www.w3.org/2001/04/xmlenc#sha512': SHA512\n}\n\nSignedXml.SignatureAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#rsa-sha1': RSASHA1,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256': RSASHA256,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512': RSASHA512,\n  // Disabled by default due to key confusion concerns.\n  // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1\n}\n\n/**\n * Due to key-confusion issues, its risky to have both hmac\n * and digital signature algos enabled at the same time.\n * This enables HMAC and disables other signing algos.\n */\nSignedXml.enableHMAC = function () {\n  SignedXml.SignatureAlgorithms = {\n    'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1\n  }\n}\n\nSignedXml.defaultNsForPrefix = {\n  ds: 'http://www.w3.org/2000/09/xmldsig#'\n};\n\nSignedXml.findAncestorNs = findAncestorNs;\n\nSignedXml.prototype.checkSignature = function(xml, callback) {\n  if (callback != null && typeof callback !== 'function') {\n    throw new Error(\"Last paramater must be a callback function\")\n  }\n\n  this.validationErrors = []\n  this.signedXml = xml\n\n  if (!this.keyInfoProvider) {\n    var err = new Error(\"cannot validate signature since no key info resolver was provided\")\n    if (!callback) {\n      throw err\n    } else {\n      callback(err)\n      return\n    }\n  }\n\n  this.signingKey = this.keyInfoProvider.getKey(this.keyInfo)\n  if (!this.signingKey) {\n    var err = new Error(\"key info provider could not resolve key info \" + this.keyInfo)\n    if (!callback) {\n      throw err\n    } else {\n      callback(err)\n      return\n    }\n  }\n\n  var doc = new Dom().parseFromString(xml)\n\n  if (!this.validateReferences(doc)) {\n    if (!callback) {\n      return false;\n    } else {\n      callback(new Error('Could not validate references'))\n      return\n    }\n  }\n\n  if (!callback) {\n    //Syncronous flow\n    if (!this.validateSignatureValue(doc)) {\n      return false\n    }\n    return true\n  } else {\n    //Asyncronous flow\n    this.validateSignatureValue(doc, function (err, isValidSignature) {\n      if (err) {\n        this.validationErrors.push(\"invalid signature: the signature value \" +\n                                        this.signatureValue + \" is incorrect\")\n        callback(err)\n      } else {\n        callback(null, isValidSignature)\n      }\n    })\n  }\n}\n\nSignedXml.prototype.getCanonSignedInfoXml = function(doc) {\n  var signedInfo = utils.findChilds(this.signatureNode, \"SignedInfo\")\n  if (signedInfo.length==0) throw new Error(\"could not find SignedInfo element in the message\")\n  \n  if(this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"\n  || this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\")\n  {\n    if(!doc || typeof(doc) !== \"object\"){\n      throw new Error(\n        \"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\"\n      );\n    }\n  }\n  \n  /**\n   * Search for ancestor namespaces before canonicalization.\n   */\n  var ancestorNamespaces = [];\n  ancestorNamespaces = findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n  \n  var c14nOptions = {\n    ancestorNamespaces: ancestorNamespaces\n  };\n  return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions)\n}\n\nSignedXml.prototype.getCanonReferenceXml = function(doc, ref, node) {\n  /**\n   * Search for ancestor namespaces before canonicalization.\n   */\n  if(Array.isArray(ref.transforms)){  \n    ref.ancestorNamespaces = findAncestorNs(doc, ref.xpath, this.namespaceResolver)\n  }\n\n  var c14nOptions = {\n    inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n    ancestorNamespaces: ref.ancestorNamespaces\n  }\n\n  return this.getCanonXml(ref.transforms, node, c14nOptions)\n}\n\nSignedXml.prototype.validateSignatureValue = function(doc, callback) {\n  var signedInfoCanon = this.getCanonSignedInfoXml(doc)\n  var signer = this.findSignatureAlgorithm(this.signatureAlgorithm)\n  var res = signer.verifySignature(signedInfoCanon, this.signingKey, this.signatureValue, callback)\n  if (!res && !callback) this.validationErrors.push(\"invalid signature: the signature value \" +\n                                        this.signatureValue + \" is incorrect\")\n  return res\n}\n\nSignedXml.prototype.calculateSignatureValue = function(doc, callback) {\n  var signedInfoCanon = this.getCanonSignedInfoXml(doc)\n  var signer = this.findSignatureAlgorithm(this.signatureAlgorithm)\n  this.signatureValue = signer.getSignature(signedInfoCanon, this.signingKey, callback)\n}\n\nSignedXml.prototype.findSignatureAlgorithm = function(name) {\n  var algo = SignedXml.SignatureAlgorithms[name]\n  if (algo) return new algo()\n  else throw new Error(\"signature algorithm '\" + name + \"' is not supported\");\n}\n\nSignedXml.prototype.findCanonicalizationAlgorithm = function(name) {\n  var algo = SignedXml.CanonicalizationAlgorithms[name]\n  if (algo) return new algo()\n  else throw new Error(\"canonicalization algorithm '\" + name + \"' is not supported\");\n}\n\nSignedXml.prototype.findHashAlgorithm = function(name) {\n  var algo = SignedXml.HashAlgorithms[name]\n  if (algo) return new algo()\n  else throw new Error(\"hash algorithm '\" + name + \"' is not supported\");\n}\n\n\nSignedXml.prototype.validateReferences = function(doc) {\n  for (var r in this.references) {\n    if (!this.references.hasOwnProperty(r)) continue;\n\n    var ref = this.references[r]\n\n    var uri = ref.uri[0]==\"#\" ? ref.uri.substring(1) : ref.uri\n    var elem = [];\n\n    if (uri==\"\") {\n      elem = xpath.select(\"//*\", doc)\n    }\n    else if (uri.indexOf(\"'\") != -1) {\n      // xpath injection\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\n    }\n    else {\n      var elemXpath;\n      var num_elements_for_id = 0;\n      for (var index in this.idAttributes) {\n        if (!this.idAttributes.hasOwnProperty(index)) continue;\n        var tmp_elemXpath = \"//*[@*[local-name(.)='\" + this.idAttributes[index] + \"']='\" + uri + \"']\";\n        var tmp_elem = xpath.select(tmp_elemXpath, doc)\n        num_elements_for_id += tmp_elem.length;\n        if (tmp_elem.length > 0) {\n          elem = tmp_elem;\n          elemXpath = tmp_elemXpath;\n        }\n      }\n      if (num_elements_for_id > 1) {\n          throw new Error('Cannot validate a document which contains multiple elements with the ' +\n          'same value for the ID / Id / Id attributes, in order to prevent ' +\n          'signature wrapping attack.');\n      }\n\n      ref.xpath = elemXpath;\n    }\n\n    if (elem.length==0) {\n      this.validationErrors.push(\"invalid signature: the signature refernces an element with uri \"+\n                        ref.uri + \" but could not find such element in the xml\")\n      return false\n    }\n  \n    var canonXml = this.getCanonReferenceXml(doc, ref, elem[0])\n\n    var hash = this.findHashAlgorithm(ref.digestAlgorithm)\n    var digest = hash.getHash(canonXml)\n\n    if (!validateDigestValue(digest, ref.digestValue)) {\n      this.validationErrors.push(\"invalid signature: for uri \" + ref.uri +\n                                \" calculated digest is \"  + digest +\n                                \" but the xml to validate supplies digest \" + ref.digestValue)\n\n      return false\n    }\n  }\n  return true\n}\n\nfunction validateDigestValue(digest, expectedDigest) {\n  var buffer, expectedBuffer;\n\n  var majorVersion = /^v(\\d+)/.exec(process.version)[1];\n\n  if (+majorVersion >= 6) {\n    buffer = Buffer.from(digest, 'base64');\n    expectedBuffer = Buffer.from(expectedDigest, 'base64');\n  } else {\n    // Compatibility with Node < 5.10.0\n    buffer = new Buffer(digest, 'base64');\n    expectedBuffer = new Buffer(expectedDigest, 'base64');\n  }\n\n  if (typeof buffer.equals === 'function') {\n    return buffer.equals(expectedBuffer);\n  }\n\n  // Compatibility with Node < 0.11.13\n  if (buffer.length !== expectedBuffer.length) {\n    return false;\n  }\n\n  for (var i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== expectedBuffer[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nSignedXml.prototype.loadSignature = function(signatureNode) {\n  if (typeof signatureNode === 'string') {\n    this.signatureNode = signatureNode = new Dom().parseFromString(signatureNode);\n  } else {\n    this.signatureNode = signatureNode;\n  }\n\n  this.signatureXml = signatureNode.toString();\n\n  var nodes = xpath.select(\".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\", signatureNode)\n  if (nodes.length==0) throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\")\n  this.canonicalizationAlgorithm = nodes[0].value\n\n  this.signatureAlgorithm =\n    utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureMethod']/@Algorithm\").value\n\n  this.references = []\n  var references = xpath.select(\".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\", signatureNode)\n  if (references.length == 0) throw new Error(\"could not find any Reference elements\")\n\n  for (var i in references) {\n    if (!references.hasOwnProperty(i)) continue;\n\n    this.loadReference(references[i])\n  }\n\n  this.signatureValue =\n    utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureValue']/text()\").data.replace(/\\r?\\n/g, '')\n\n  this.keyInfo = xpath.select(\".//*[local-name(.)='KeyInfo']\", signatureNode)\n}\n\n/**\n * Load the reference xml node to a model\n *\n */\nSignedXml.prototype.loadReference = function(ref) {\n  var nodes = utils.findChilds(ref, \"DigestMethod\")\n  if (nodes.length==0) throw new Error(\"could not find DigestMethod in reference \" + ref.toString())\n  var digestAlgoNode = nodes[0]\n\n  var attr = utils.findAttr(digestAlgoNode, \"Algorithm\")\n  if (!attr) throw new Error(\"could not find Algorithm attribute in node \" + digestAlgoNode.toString())\n  var digestAlgo = attr.value\n\n  nodes = utils.findChilds(ref, \"DigestValue\")\n  if (nodes.length==0) throw new Error(\"could not find DigestValue node in reference \" + ref.toString())\n  if (nodes[0].childNodes.length==0 || !nodes[0].firstChild.data)\n  {\n    throw new Error(\"could not find the value of DigestValue in \" + nodes[0].toString())\n  }\n  var digestValue = nodes[0].firstChild.data\n\n  var transforms = []\n  var inclusiveNamespacesPrefixList;\n  nodes = utils.findChilds(ref, \"Transforms\")\n  if (nodes.length!=0) {\n    var transformsNode = nodes[0]\n    var transformsAll = utils.findChilds(transformsNode, \"Transform\")\n    for (var t in transformsAll) {\n      if (!transformsAll.hasOwnProperty(t)) continue;\n\n      var trans = transformsAll[t]\n      transforms.push(utils.findAttr(trans, \"Algorithm\").value)\n    }\n\n    var inclusiveNamespaces = utils.findChilds(trans, \"InclusiveNamespaces\")\n    if (inclusiveNamespaces.length > 0) {\n      //Should really only be one prefix list, but maybe there's some circumstances where more than one to lets handle it\n      for (var i = 0; i<inclusiveNamespaces.length; i++) {\n        if (inclusiveNamespacesPrefixList) {\n          inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList + \" \" + inclusiveNamespaces[i].getAttribute('PrefixList');\n        } else {\n          inclusiveNamespacesPrefixList = inclusiveNamespaces[i].getAttribute('PrefixList');\n        }\n      }\n    }\n  }\n\n  var hasImplicitTransforms = (Array.isArray(this.implicitTransforms) && this.implicitTransforms.length > 0);\n  if(hasImplicitTransforms){\n    this.implicitTransforms.forEach(function(t){\n      transforms.push(t);\n    });\n  }\n  \n/**\n * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n * See:\n * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n */\n  if (transforms.length === 0 || transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\") {\n      transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\")\n  }\n\n  this.addReference(null, transforms, digestAlgo, utils.findAttr(ref, \"URI\").value, digestValue, inclusiveNamespacesPrefixList, false)\n}\n\nSignedXml.prototype.addReference = function(xpath, transforms, digestAlgorithm, uri, digestValue, inclusiveNamespacesPrefixList, isEmptyUri) {\n  this.references.push({\n    \"xpath\": xpath,\n    \"transforms\": transforms ? transforms : [\"http://www.w3.org/2001/10/xml-exc-c14n#\"] ,\n    \"digestAlgorithm\": digestAlgorithm ? digestAlgorithm : \"http://www.w3.org/2000/09/xmldsig#sha1\",\n    \"uri\": uri,\n    \"digestValue\": digestValue,\n    \"inclusiveNamespacesPrefixList\": inclusiveNamespacesPrefixList,\n    \"isEmptyUri\": isEmptyUri\n  });\n}\n\n/**\n * Compute the signature of the given xml (usign the already defined settings)\n *\n * Options:\n *\n * - `prefix` {String} Adds a prefix for the generated signature tags\n * - `attrs` {Object} A hash of attributes and values `attrName: value` to add to the signature root node\n * - `location` {{ reference: String, action: String }}\n * - `existingPrefixes` {Object} A hash of prefixes and namespaces `prefix: namespace` already in the xml\n *   An object with a `reference` key which should\n *   contain a XPath expression, an `action` key which\n *   should contain one of the following values:\n *   `append`, `prepend`, `before`, `after`\n *\n */\nSignedXml.prototype.computeSignature = function(xml, opts, callback) {\n  if (typeof opts === 'function' && callback == null) {\n    callback = opts\n  }\n\n  if (callback != null && typeof callback !== 'function') {\n    throw new Error(\"Last paramater must be a callback function\")\n  }\n\n  var doc = new Dom().parseFromString(xml),\n      xmlNsAttr = \"xmlns\",\n      signatureAttrs = [],\n      location,\n      attrs,\n      prefix,\n      currentPrefix;\n\n  var validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n\n  opts = opts || {};\n  prefix = opts.prefix;\n  attrs = opts.attrs || {};\n  location = opts.location || {};\n  var existingPrefixes = opts.existingPrefixes || {};\n\n  this.namespaceResolver = {\n    lookupNamespaceURI: function(prefix) {       \n      return existingPrefixes[prefix];\n    }\n  }\n\n  // defaults to the root node\n  location.reference = location.reference || \"/*\";\n  // defaults to append action\n  location.action = location.action || \"append\";\n\n  if (validActions.indexOf(location.action) === -1) {\n    var err = new Error(\"location.action option has an invalid action: \" + location.action +\n      \", must be any of the following values: \" + validActions.join(\", \"));\n    if (!callback) {\n      throw err;\n    } else {\n      callback(err, null)\n      return\n    }\n  }\n\n  // automatic insertion of `:`\n  if (prefix) {\n    xmlNsAttr += \":\" + prefix;\n    currentPrefix = prefix + \":\";\n  } else {\n    currentPrefix = \"\";\n  }\n\n  Object.keys(attrs).forEach(function(name) {\n    if (name !== \"xmlns\" && name !== xmlNsAttr) {\n      signatureAttrs.push(name + \"=\\\"\" + attrs[name] + \"\\\"\");\n    }\n  });\n\n  // add the xml namespace attribute\n  signatureAttrs.push(xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\"\");\n\n  var signatureXml = \"<\" + currentPrefix + \"Signature \" + signatureAttrs.join(\" \") + \">\"\n\n  signatureXml += this.createSignedInfo(doc, prefix);\n  signatureXml += this.getKeyInfo(prefix)\n  signatureXml += \"</\" + currentPrefix + \"Signature>\"\n\n  this.originalXmlWithIds = doc.toString()\n\n  var existingPrefixesString = \"\"\n  Object.keys(existingPrefixes).forEach(function(key) {\n    existingPrefixesString += \"xmlns:\" + key + '=\"' + existingPrefixes[key] + '\" '\n  });\n\n  // A trick to remove the namespaces that already exist in the xml\n  // This only works if the prefix and namespace match with those in te xml\n  var dummySignatureWrapper = \"<Dummy \" + existingPrefixesString + \">\" + signatureXml + \"</Dummy>\"\n  var xml = new Dom().parseFromString(dummySignatureWrapper)\n  var signatureDoc = xml.documentElement.firstChild;\n\n  var referenceNode = xpath.select(location.reference, doc);\n\n  if (!referenceNode || referenceNode.length === 0) {\n    var err = new Error(\"the following xpath cannot be used because it was not found: \" + location.reference);\n    if (!callback) {\n      throw err\n    } else {\n      callback(err, null)\n      return\n    }\n  }\n\n  referenceNode = referenceNode[0];\n\n  if (location.action === \"append\") {\n    referenceNode.appendChild(signatureDoc);\n  } else if (location.action === \"prepend\") {\n    referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n  } else if (location.action === \"before\") {\n    referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n  } else if (location.action === \"after\") {\n    referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n  }\n\n  this.signatureNode = signatureDoc\n  var signedInfoNode = utils.findChilds(this.signatureNode, \"SignedInfo\")\n  if (signedInfoNode.length == 0) {\n    var err = new Error(\"could not find SignedInfo element in the message\")\n    if (!callback) {\n      throw err\n    } else {\n      callback(err)\n      return\n    }\n  }\n  signedInfoNode = signedInfoNode[0];\n\n  if (!callback) {\n    //Synchronous flow\n    this.calculateSignatureValue(doc)\n    signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling)\n    this.signatureXml = signatureDoc.toString()\n    this.signedXml = doc.toString()\n  } else {\n    var self = this\n    //Asynchronous flow\n    this.calculateSignatureValue(doc, function(err, signature) {\n      if (err) {\n        callback(err)\n      } else {\n        self.signatureValue = signature\n        signatureDoc.insertBefore(self.createSignature(prefix), signedInfoNode.nextSibling)\n        self.signatureXml = signatureDoc.toString()\n        self.signedXml = doc.toString()\n        callback(null, self)\n      }\n    })\n  }\n}\n\nSignedXml.prototype.getKeyInfo = function(prefix) {\n  var res = \"\"\n  var currentPrefix\n\n  currentPrefix = prefix || ''\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix\n\n  if (this.keyInfoProvider) {\n    res += \"<\" + currentPrefix + \"KeyInfo>\"\n    res += this.keyInfoProvider.getKeyInfo(this.signingKey, prefix)\n    res += \"</\" + currentPrefix + \"KeyInfo>\"\n  }\n  return res\n}\n\n/**\n * Generate the Reference nodes (as part of the signature process)\n *\n */\nSignedXml.prototype.createReferences = function(doc, prefix) {\n\n  var res = \"\"\n\n  prefix = prefix || ''\n  prefix = prefix ? prefix + ':' : prefix\n\n  for (var n in this.references) {\n    if (!this.references.hasOwnProperty(n)) continue;\n\n    var ref = this.references[n]\n      , nodes = xpath.selectWithResolver(ref.xpath, doc, this.namespaceResolver)\n\n    if (nodes.length==0) {\n      throw new Error('the following xpath cannot be signed because it was not found: ' + ref.xpath)\n    }\n\n    for (var h in nodes) {\n      if (!nodes.hasOwnProperty(h)) continue;\n\n      var node = nodes[h]\n      if (ref.isEmptyUri) {\n        res += \"<\" + prefix + \"Reference URI=\\\"\\\">\"\n      }\n      else {\n        var id = this.ensureHasId(node);\n        ref.uri = id\n        res += \"<\" + prefix + \"Reference URI=\\\"#\" + id + \"\\\">\"\n      }\n      res += \"<\" + prefix + \"Transforms>\"\n      for (var t in ref.transforms) {\n        if (!ref.transforms.hasOwnProperty(t)) continue;\n\n        var trans = ref.transforms[t]\n        var transform = this.findCanonicalizationAlgorithm(trans)\n        res += \"<\" + prefix + \"Transform Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\"\n      }\n\n      var canonXml = this.getCanonReferenceXml(doc, ref, node)\n\n      var digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm)\n      res += \"</\" + prefix + \"Transforms>\"+\n             \"<\" + prefix + \"DigestMethod Algorithm=\\\"\" + digestAlgorithm.getAlgorithmName() + \"\\\" />\"+\n              \"<\" + prefix + \"DigestValue>\" + digestAlgorithm.getHash(canonXml) + \"</\" + prefix + \"DigestValue>\"+\n              \"</\" + prefix + \"Reference>\"\n    }\n  }\n\n  return res\n}\n\nSignedXml.prototype.getCanonXml = function(transforms, node, options) {\n  options = options || {};\n  options.defaultNsForPrefix = options.defaultNsForPrefix || SignedXml.defaultNsForPrefix;\n  options.signatureNode = this.signatureNode;\n\n  var canonXml = node.cloneNode(true) // Deep clone\n\n  for (var t in transforms) {\n    if (!transforms.hasOwnProperty(t)) continue;\n\n    var transform = this.findCanonicalizationAlgorithm(transforms[t])\n    canonXml = transform.process(canonXml, options);\n    //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n    //This eitehr needs to be more explicit in the API, or all should return the same.\n    //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would inccorectly minimize empty tags\n    //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n    //enveloped transformation returns Node since if it would return String consider this case:\n    //<x xmlns:p='ns'><p:y/></x>\n    //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n  }\n  return canonXml.toString()\n}\n\n/**\n * Ensure an element has Id attribute. If not create it with unique value.\n * Work with both normal and wssecurity Id flavour\n */\nSignedXml.prototype.ensureHasId = function(node) {\n  var attr\n\n  if (this.idMode==\"wssecurity\") {\n    attr = utils.findAttr(node,\n      \"Id\",\n      \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\")\n  }\n  else {\n    for (var index in this.idAttributes) {\n      if (!this.idAttributes.hasOwnProperty(index)) continue;\n\n      attr = utils.findAttr(node, this.idAttributes[index], null);\n      if (attr) break;\n    }\n  }\n\n  if (attr) return attr.value\n\n  //add the attribute\n  var id = \"_\" + this.id++\n\n  if (this.idMode==\"wssecurity\") {\n    node.setAttributeNS(\"http://www.w3.org/2000/xmlns/\",\n      \"xmlns:wsu\",\n      \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\")\n    node.setAttributeNS(\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      \"wsu:Id\",\n      id)\n  }\n  else {\n   node.setAttribute(\"Id\", id)\n  }\n\n  return id\n}\n\n/**\n * Create the SignedInfo element\n *\n */\nSignedXml.prototype.createSignedInfo = function(doc, prefix) {\n  var transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm)\n  var algo = this.findSignatureAlgorithm(this.signatureAlgorithm)\n  var currentPrefix\n\n  currentPrefix = prefix || ''\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix\n\n  var res = \"<\" + currentPrefix + \"SignedInfo>\"\n  res += \"<\" + currentPrefix + \"CanonicalizationMethod Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\" +\n          \"<\" + currentPrefix + \"SignatureMethod Algorithm=\\\"\" + algo.getAlgorithmName() + \"\\\" />\"\n\n  res += this.createReferences(doc, prefix)\n  res += \"</\" + currentPrefix + \"SignedInfo>\"\n  return res\n}\n\n/**\n * Create the Signature element\n *\n */\nSignedXml.prototype.createSignature = function(prefix) {\n  var xmlNsAttr = 'xmlns'\n\n  if (prefix) {\n    xmlNsAttr += ':' + prefix;\n    prefix += ':';\n  } else {\n    prefix = '';\n  }\n\n  var signatureValueXml = \"<\" + prefix + \"SignatureValue>\" + this.signatureValue + \"</\" + prefix + \"SignatureValue>\"\n  //the canonicalization requires to get a valid xml node.\n  //we need to wrap the info in a dummy signature since it contains the default namespace.\n  var dummySignatureWrapper = \"<\" + prefix + \"Signature \" + xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\">\" +\n                              signatureValueXml +\n                              \"</\" + prefix + \"Signature>\"\n\n  var doc = new Dom().parseFromString(dummySignatureWrapper)\n  return doc.documentElement.firstChild;\n}\n\n\nSignedXml.prototype.getSignatureXml = function() {\n  return this.signatureXml\n}\n\nSignedXml.prototype.getOriginalXmlWithIds = function() {\n  return this.originalXmlWithIds\n}\n\nSignedXml.prototype.getSignedXml = function() {\n  return this.signedXml\n}\n"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;AAAA,IACIC,GAAG,GAAGD,OAAO,CAAC,gBAAD,CAAP,CAA0BE,SADpC;AAAA,IAEIC,KAAK,GAAGH,OAAO,CAAC,SAAD,CAFnB;AAAA,IAGII,IAAI,GAAGJ,OAAO,CAAC,yBAAD,CAHlB;AAAA,IAIIK,QAAQ,GAAGL,OAAO,CAAC,8BAAD,CAJtB;AAAA,IAKIM,kBAAkB,GAAGN,OAAO,CAAC,uBAAD,CAAP,CAAiCM,kBAL1D;AAAA,IAMIC,MAAM,GAAGP,OAAO,CAAC,QAAD,CANpB;AAAA,IAOIQ,EAAE,GAAGR,OAAO,CAAC,IAAD,CAPhB;;AASAS,OAAO,CAACC,SAAR,GAAoBA,SAApB;AACAD,OAAO,CAACE,WAAR,GAAsBA,WAAtB;AAEA;AACA;AACA;AACA;;AACA,SAASA,WAAT,CAAqBC,IAArB,EAA2B;EACzB,KAAKA,IAAL,GAAYA,IAAZ;;EAEA,KAAKC,UAAL,GAAkB,UAASC,GAAT,EAAcC,MAAd,EAAsB;IACtCA,MAAM,GAAGA,MAAM,IAAI,EAAnB;IACAA,MAAM,GAAGA,MAAM,GAAGA,MAAM,GAAG,GAAZ,GAAkBA,MAAjC;IACA,OAAO,MAAMA,MAAN,GAAe,aAAf,GAA+BA,MAA/B,GAAwC,WAA/C;EACD,CAJD;;EAMA,KAAKC,MAAL,GAAc,UAASC,OAAT,EAAkB;IAC9B,OAAOT,EAAE,CAACU,YAAH,CAAgB,KAAKN,IAArB,CAAP;EACD,CAFD;AAGD;AAED;AACA;AACA;AACA;;;AACA,SAASO,IAAT,GAAgB;EAEd,KAAKC,OAAL,GAAe,UAASC,GAAT,EAAc;IAC3B,IAAIC,MAAM,GAAGf,MAAM,CAACgB,UAAP,CAAkB,MAAlB,CAAb;IACAD,MAAM,CAACE,MAAP,CAAcH,GAAd,EAAmB,MAAnB;IACA,IAAII,GAAG,GAAGH,MAAM,CAACI,MAAP,CAAc,QAAd,CAAV;IACA,OAAOD,GAAP;EACD,CALD;;EAOA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,wCAAP;EACD,CAFD;AAGD;;AAED,SAASC,MAAT,GAAkB;EAEhB,KAAKR,OAAL,GAAe,UAASC,GAAT,EAAc;IAC3B,IAAIC,MAAM,GAAGf,MAAM,CAACgB,UAAP,CAAkB,QAAlB,CAAb;IACAD,MAAM,CAACE,MAAP,CAAcH,GAAd,EAAmB,MAAnB;IACA,IAAII,GAAG,GAAGH,MAAM,CAACI,MAAP,CAAc,QAAd,CAAV;IACA,OAAOD,GAAP;EACD,CALD;;EAOA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,yCAAP;EACD,CAFD;AAGD;;AAED,SAASE,MAAT,GAAkB;EAEhB,KAAKT,OAAL,GAAe,UAASC,GAAT,EAAc;IAC3B,IAAIC,MAAM,GAAGf,MAAM,CAACgB,UAAP,CAAkB,QAAlB,CAAb;IACAD,MAAM,CAACE,MAAP,CAAcH,GAAd,EAAmB,MAAnB;IACA,IAAII,GAAG,GAAGH,MAAM,CAACI,MAAP,CAAc,QAAd,CAAV;IACA,OAAOD,GAAP;EACD,CALD;;EAOA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,yCAAP;EACD,CAFD;AAGD;AAGD;AACA;AACA;AACA;;;AACA,SAASG,OAAT,GAAmB;EAEjB;AACF;AACA;AACA;EACE,KAAKC,YAAL,GAAoB,UAASC,UAAT,EAAqBC,UAArB,EAAiCC,QAAjC,EAA2C;IAC7D,IAAIC,MAAM,GAAG5B,MAAM,CAAC6B,UAAP,CAAkB,UAAlB,CAAb;IACAD,MAAM,CAACX,MAAP,CAAcQ,UAAd;IACA,IAAIP,GAAG,GAAGU,MAAM,CAACE,IAAP,CAAYJ,UAAZ,EAAwB,QAAxB,CAAV;IACA,IAAIC,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;EAQA;AACF;AACA;AACA;;;EACE,KAAKa,eAAL,GAAuB,UAASC,GAAT,EAAczB,GAAd,EAAmB0B,cAAnB,EAAmCN,QAAnC,EAA6C;IAClE,IAAIO,QAAQ,GAAGlC,MAAM,CAACmC,YAAP,CAAoB,UAApB,CAAf;IACAD,QAAQ,CAACjB,MAAT,CAAgBe,GAAhB;IACA,IAAId,GAAG,GAAGgB,QAAQ,CAACE,MAAT,CAAgB7B,GAAhB,EAAqB0B,cAArB,EAAqC,QAArC,CAAV;IACA,IAAIN,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;;EAQA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,4CAAP;EACD,CAFD;AAID;AAGD;AACA;AACA;AACA;;;AACA,SAASiB,SAAT,GAAqB;EAEnB;AACF;AACA;AACA;EACE,KAAKb,YAAL,GAAoB,UAASC,UAAT,EAAqBC,UAArB,EAAiCC,QAAjC,EAA2C;IAC7D,IAAIC,MAAM,GAAG5B,MAAM,CAAC6B,UAAP,CAAkB,YAAlB,CAAb;IACAD,MAAM,CAACX,MAAP,CAAcQ,UAAd;IACA,IAAIP,GAAG,GAAGU,MAAM,CAACE,IAAP,CAAYJ,UAAZ,EAAwB,QAAxB,CAAV;IACA,IAAIC,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;EAQA;AACF;AACA;AACA;;;EACE,KAAKa,eAAL,GAAuB,UAASC,GAAT,EAAczB,GAAd,EAAmB0B,cAAnB,EAAmCN,QAAnC,EAA6C;IAClE,IAAIO,QAAQ,GAAGlC,MAAM,CAACmC,YAAP,CAAoB,YAApB,CAAf;IACAD,QAAQ,CAACjB,MAAT,CAAgBe,GAAhB;IACA,IAAId,GAAG,GAAGgB,QAAQ,CAACE,MAAT,CAAgB7B,GAAhB,EAAqB0B,cAArB,EAAqC,QAArC,CAAV;IACA,IAAIN,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;;EAQA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,mDAAP;EACD,CAFD;AAID;AAED;AACA;AACA;AACA;;;AACA,SAASkB,SAAT,GAAqB;EAEnB;AACF;AACA;AACA;EACE,KAAKd,YAAL,GAAoB,UAASC,UAAT,EAAqBC,UAArB,EAAiCC,QAAjC,EAA2C;IAC7D,IAAIC,MAAM,GAAG5B,MAAM,CAAC6B,UAAP,CAAkB,YAAlB,CAAb;IACAD,MAAM,CAACX,MAAP,CAAcQ,UAAd;IACA,IAAIP,GAAG,GAAGU,MAAM,CAACE,IAAP,CAAYJ,UAAZ,EAAwB,QAAxB,CAAV;IACA,IAAIC,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;EAQA;AACF;AACA;AACA;;;EACE,KAAKa,eAAL,GAAuB,UAASC,GAAT,EAAczB,GAAd,EAAmB0B,cAAnB,EAAmCN,QAAnC,EAA6C;IAClE,IAAIO,QAAQ,GAAGlC,MAAM,CAACmC,YAAP,CAAoB,YAApB,CAAf;IACAD,QAAQ,CAACjB,MAAT,CAAgBe,GAAhB;IACA,IAAId,GAAG,GAAGgB,QAAQ,CAACE,MAAT,CAAgB7B,GAAhB,EAAqB0B,cAArB,EAAqC,QAArC,CAAV;IACA,IAAIN,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAOT,GAAP,CAAR;IACd,OAAOA,GAAP;EACD,CAND;;EAQA,KAAKE,gBAAL,GAAwB,YAAW;IACjC,OAAO,mDAAP;EACD,CAFD;AAGD;;AAED,SAASmB,QAAT,GAAoB;EAChB,KAAKR,eAAL,GAAuB,UAASC,GAAT,EAAczB,GAAd,EAAmB0B,cAAnB,EAAmC;IACtD,IAAIC,QAAQ,GAAGlC,MAAM,CAACwC,UAAP,CAAkB,MAAlB,EAA0BjC,GAA1B,CAAf;IACA2B,QAAQ,CAACjB,MAAT,CAAgBe,GAAhB;IACA,IAAId,GAAG,GAAGgB,QAAQ,CAACf,MAAT,CAAgB,QAAhB,CAAV;IACA,OAAOD,GAAG,KAAKe,cAAf;EACH,CALD;;EAOA,KAAKb,gBAAL,GAAwB,YAAW;IAC/B,OAAO,6CAAP;EACH,CAFD;;EAIA,KAAKI,YAAL,GAAoB,UAASC,UAAT,EAAqBC,UAArB,EAAiC;IACjD,IAAIQ,QAAQ,GAAGlC,MAAM,CAACwC,UAAP,CAAkB,MAAlB,EAA0Bd,UAA1B,CAAf;IACAQ,QAAQ,CAACjB,MAAT,CAAgBQ,UAAhB;IACA,IAAIP,GAAG,GAAGgB,QAAQ,CAACf,MAAT,CAAgB,QAAhB,CAAV;IACA,OAAOD,GAAP;EACH,CALD;AAMH;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASuB,cAAT,CAAwBC,GAAxB,EAA6BC,cAA7B,EAA6CC,iBAA7C,EAA+D;EAC7D,IAAIC,SAAS,GAAGrD,KAAK,CAACsD,kBAAN,CAAyBH,cAAzB,EAAyCD,GAAzC,EAA8CE,iBAA9C,CAAhB;;EAEA,IAAG,CAACG,KAAK,CAACC,OAAN,CAAcH,SAAd,CAAD,IAA6BA,SAAS,CAACI,MAAV,GAAmB,CAAnD,EAAqD;IACnD,OAAO,EAAP;EACD,CAL4D,CAO7D;;;EACA,IAAIC,UAAU,GAAGC,yBAAyB,CAACN,SAAS,CAAC,CAAD,CAAV,CAA1C;EACA,IAAIO,0BAA0B,GAAG,EAAjC;;EACA,KAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACH,UAAU,CAACD,MAAzB,EAAgCI,CAAC,EAAjC,EAAoC;IAClC,IAAIC,YAAY,GAAG,IAAnB;;IACA,KAAI,IAAIC,CAAR,IAAaH,0BAAb,EAAwC;MACtC,IAAGA,0BAA0B,CAACG,CAAD,CAA1B,CAA8B/C,MAA9B,KAAyC0C,UAAU,CAACG,CAAD,CAAV,CAAc7C,MAA1D,EAAiE;QAC/D8C,YAAY,GAAG,KAAf;QACA;MACD;IACF;;IAED,IAAGA,YAAH,EAAgB;MACdF,0BAA0B,CAACI,IAA3B,CAAgCN,UAAU,CAACG,CAAD,CAA1C;IACD;EACF,CAtB4D,CAwB7D;;;EACA,IAAII,WAAW,GAAG,EAAlB;EACA,IAAIC,gBAAgB,GAAGb,SAAS,CAAC,CAAD,CAAT,CAAac,UAApC;;EACA,KAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACR,0BAA0B,CAACH,MAAzC,EAAgDW,CAAC,EAAjD,EAAoD;IAClD,IAAIC,QAAQ,GAAG,IAAf;;IACA,KAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACJ,gBAAgB,CAACT,MAA/B,EAAsCa,CAAC,EAAvC,EAA0C;MACxC,IAAIC,QAAQ,GAAGL,gBAAgB,CAACI,CAAD,CAAhB,CAAoBC,QAAnC;MACA,IAAGA,QAAQ,CAACC,MAAT,CAAgB,SAAhB,MAA+B,CAAC,CAAnC,EAAsC;MACtC,IAAIxD,MAAM,GAAGuD,QAAQ,CAACE,OAAT,CAAiB,SAAjB,EAA4B,EAA5B,CAAb;;MACA,IAAGb,0BAA0B,CAACQ,CAAD,CAA1B,CAA8BpD,MAA9B,KAAyCA,MAA5C,EAAmD;QACjDqD,QAAQ,GAAG,KAAX;QACA;MACD;IACF;;IAED,IAAGA,QAAH,EAAY;MACVJ,WAAW,CAACD,IAAZ,CAAiBJ,0BAA0B,CAACQ,CAAD,CAA3C;IACD;EACF;;EAED,OAAOH,WAAP;AACD;;AAID,SAASN,yBAAT,CAAmCe,IAAnC,EAAyCC,OAAzC,EAAiD;EAC/C,IAAG,CAACA,OAAJ,EAAY;IACVA,OAAO,GAAG,EAAV;EACD;;EAED,IAAIC,MAAM,GAAGF,IAAI,CAACG,UAAlB;;EAEA,IAAG,CAACD,MAAJ,EAAW;IACT,OAAOD,OAAP;EACD;;EAED,IAAGC,MAAM,CAACT,UAAP,IAAqBS,MAAM,CAACT,UAAP,CAAkBV,MAAlB,GAA2B,CAAnD,EAAqD;IACnD,KAAI,IAAII,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACe,MAAM,CAACT,UAAP,CAAkBV,MAAhC,EAAuCI,CAAC,EAAxC,EAA2C;MACzC,IAAIiB,IAAI,GAAGF,MAAM,CAACT,UAAP,CAAkBN,CAAlB,CAAX;;MACA,IAAGiB,IAAI,IAAIA,IAAI,CAACP,QAAb,IAAyBO,IAAI,CAACP,QAAL,CAAcC,MAAd,CAAqB,SAArB,MAAoC,CAAC,CAAjE,EAAmE;QACjEG,OAAO,CAACX,IAAR,CAAa;UAAChD,MAAM,EAAE8D,IAAI,CAACP,QAAL,CAAcE,OAAd,CAAsB,SAAtB,EAAiC,EAAjC,CAAT;UAA+CM,YAAY,EAAED,IAAI,CAACE;QAAlE,CAAb;MACD;IACF;EACF;;EAED,OAAOrB,yBAAyB,CAACiB,MAAD,EAASD,OAAT,CAAhC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShE,SAAT,CAAmBsE,MAAnB,EAA2BC,OAA3B,EAAoC;EAClC,KAAKA,OAAL,GAAeA,OAAO,IAAI,EAA1B;EACA,KAAKD,MAAL,GAAcA,MAAd;EACA,KAAKE,UAAL,GAAkB,EAAlB;EACA,KAAKC,EAAL,GAAU,CAAV;EACA,KAAKlD,UAAL,GAAkB,IAAlB;EACA,KAAKmD,kBAAL,GAA0B,KAAKH,OAAL,CAAaG,kBAAb,IAAmC,4CAA7D;EACA,KAAKC,eAAL,GAAuB,IAAvB;EACA,KAAKC,yBAAL,GAAiC,KAAKL,OAAL,CAAaK,yBAAb,IAA0C,yCAA3E;EACA,KAAKC,SAAL,GAAiB,EAAjB;EACA,KAAKC,YAAL,GAAoB,EAApB;EACA,KAAKC,aAAL,GAAqB,IAArB;EACA,KAAKjD,cAAL,GAAsB,EAAtB;EACA,KAAKkD,kBAAL,GAA0B,EAA1B;EACA,KAAKC,gBAAL,GAAwB,EAAxB;EACA,KAAK1E,OAAL,GAAe,IAAf;EACA,KAAK2E,YAAL,GAAoB,CAAE,IAAF,EAAQ,IAAR,EAAc,IAAd,CAApB;EACA,IAAI,KAAKX,OAAL,CAAaY,WAAjB,EAA8B,KAAKD,YAAL,CAAkBE,MAAlB,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B,KAAKb,OAAL,CAAaY,WAA5C;EAC9B,KAAKE,kBAAL,GAA0B,KAAKd,OAAL,CAAac,kBAAb,IAAmC,EAA7D;AACD;;AAEDrF,SAAS,CAACsF,0BAAV,GAAuC;EACrC,mDAAmD5F,IAAI,CAAC6F,oBADnB;EAErC,gEAAgE7F,IAAI,CAAC8F,gCAFhC;EAGrC,2CAA2C7F,QAAQ,CAAC8F,yBAHf;EAIrC,uDAAuD9F,QAAQ,CAAC+F,qCAJ3B;EAKrC,yDAAyD9F;AALpB,CAAvC;AAQAI,SAAS,CAAC2F,cAAV,GAA2B;EACzB,0CAA0ClF,IADjB;EAEzB,2CAA2CS,MAFlB;EAGzB,2CAA2CC;AAHlB,CAA3B;AAMAnB,SAAS,CAAC4F,mBAAV,GAAgC;EAC9B,8CAA8CxE,OADhB;EAE9B,qDAAqDc,SAFvB;EAG9B,qDAAqDC,SAHvB,CAI9B;EACA;;AAL8B,CAAhC;AAQA;AACA;AACA;AACA;AACA;;AACAnC,SAAS,CAAC6F,UAAV,GAAuB,YAAY;EACjC7F,SAAS,CAAC4F,mBAAV,GAAgC;IAC9B,+CAA+CxD;EADjB,CAAhC;AAGD,CAJD;;AAMApC,SAAS,CAAC8F,kBAAV,GAA+B;EAC7BC,EAAE,EAAE;AADyB,CAA/B;AAIA/F,SAAS,CAACsC,cAAV,GAA2BA,cAA3B;;AAEAtC,SAAS,CAACgG,SAAV,CAAoBC,cAApB,GAAqC,UAAStF,GAAT,EAAca,QAAd,EAAwB;EAC3D,IAAIA,QAAQ,IAAI,IAAZ,IAAoB,OAAOA,QAAP,KAAoB,UAA5C,EAAwD;IACtD,MAAM,IAAI0E,KAAJ,CAAU,4CAAV,CAAN;EACD;;EAED,KAAKjB,gBAAL,GAAwB,EAAxB;EACA,KAAKJ,SAAL,GAAiBlE,GAAjB;;EAEA,IAAI,CAAC,KAAKgE,eAAV,EAA2B;IACzB,IAAIwB,GAAG,GAAG,IAAID,KAAJ,CAAU,mEAAV,CAAV;;IACA,IAAI,CAAC1E,QAAL,EAAe;MACb,MAAM2E,GAAN;IACD,CAFD,MAEO;MACL3E,QAAQ,CAAC2E,GAAD,CAAR;MACA;IACD;EACF;;EAED,KAAK5E,UAAL,GAAkB,KAAKoD,eAAL,CAAqBrE,MAArB,CAA4B,KAAKC,OAAjC,CAAlB;;EACA,IAAI,CAAC,KAAKgB,UAAV,EAAsB;IACpB,IAAI4E,GAAG,GAAG,IAAID,KAAJ,CAAU,kDAAkD,KAAK3F,OAAjE,CAAV;;IACA,IAAI,CAACiB,QAAL,EAAe;MACb,MAAM2E,GAAN;IACD,CAFD,MAEO;MACL3E,QAAQ,CAAC2E,GAAD,CAAR;MACA;IACD;EACF;;EAED,IAAI5D,GAAG,GAAG,IAAIhD,GAAJ,GAAU6G,eAAV,CAA0BzF,GAA1B,CAAV;;EAEA,IAAI,CAAC,KAAK0F,kBAAL,CAAwB9D,GAAxB,CAAL,EAAmC;IACjC,IAAI,CAACf,QAAL,EAAe;MACb,OAAO,KAAP;IACD,CAFD,MAEO;MACLA,QAAQ,CAAC,IAAI0E,KAAJ,CAAU,+BAAV,CAAD,CAAR;MACA;IACD;EACF;;EAED,IAAI,CAAC1E,QAAL,EAAe;IACb;IACA,IAAI,CAAC,KAAK8E,sBAAL,CAA4B/D,GAA5B,CAAL,EAAuC;MACrC,OAAO,KAAP;IACD;;IACD,OAAO,IAAP;EACD,CAND,MAMO;IACL;IACA,KAAK+D,sBAAL,CAA4B/D,GAA5B,EAAiC,UAAU4D,GAAV,EAAeI,gBAAf,EAAiC;MAChE,IAAIJ,GAAJ,EAAS;QACP,KAAKlB,gBAAL,CAAsB5B,IAAtB,CAA2B,4CACK,KAAKvB,cADV,GAC2B,eADtD;QAEAN,QAAQ,CAAC2E,GAAD,CAAR;MACD,CAJD,MAIO;QACL3E,QAAQ,CAAC,IAAD,EAAO+E,gBAAP,CAAR;MACD;IACF,CARD;EASD;AACF,CA1DD;;AA4DAvG,SAAS,CAACgG,SAAV,CAAoBQ,qBAApB,GAA4C,UAASjE,GAAT,EAAc;EACxD,IAAIjB,UAAU,GAAG7B,KAAK,CAACgH,UAAN,CAAiB,KAAK1B,aAAtB,EAAqC,YAArC,CAAjB;EACA,IAAIzD,UAAU,CAACwB,MAAX,IAAmB,CAAvB,EAA0B,MAAM,IAAIoD,KAAJ,CAAU,kDAAV,CAAN;;EAE1B,IAAG,KAAKtB,yBAAL,KAAmC,iDAAnC,IACA,KAAKA,yBAAL,KAAmC,8DADtC,EAEA;IACE,IAAG,CAACrC,GAAD,IAAQ,OAAOA,GAAP,KAAgB,QAA3B,EAAoC;MAClC,MAAM,IAAI2D,KAAJ,CACJ,8FADI,CAAN;IAGD;EACF;EAED;AACF;AACA;;;EACE,IAAIQ,kBAAkB,GAAG,EAAzB;EACAA,kBAAkB,GAAGpE,cAAc,CAACC,GAAD,EAAM,gCAAN,CAAnC;EAEA,IAAIoE,WAAW,GAAG;IAChBD,kBAAkB,EAAEA;EADJ,CAAlB;EAGA,OAAO,KAAKE,WAAL,CAAiB,CAAC,KAAKhC,yBAAN,CAAjB,EAAmDtD,UAAU,CAAC,CAAD,CAA7D,EAAkEqF,WAAlE,CAAP;AACD,CAxBD;;AA0BA3G,SAAS,CAACgG,SAAV,CAAoBa,oBAApB,GAA2C,UAAStE,GAAT,EAAcuE,GAAd,EAAmB/C,IAAnB,EAAyB;EAClE;AACF;AACA;EACE,IAAGnB,KAAK,CAACC,OAAN,CAAciE,GAAG,CAACC,UAAlB,CAAH,EAAiC;IAC/BD,GAAG,CAACJ,kBAAJ,GAAyBpE,cAAc,CAACC,GAAD,EAAMuE,GAAG,CAACzH,KAAV,EAAiB,KAAKoD,iBAAtB,CAAvC;EACD;;EAED,IAAIkE,WAAW,GAAG;IAChBK,6BAA6B,EAAEF,GAAG,CAACE,6BADnB;IAEhBN,kBAAkB,EAAEI,GAAG,CAACJ;EAFR,CAAlB;EAKA,OAAO,KAAKE,WAAL,CAAiBE,GAAG,CAACC,UAArB,EAAiChD,IAAjC,EAAuC4C,WAAvC,CAAP;AACD,CAdD;;AAgBA3G,SAAS,CAACgG,SAAV,CAAoBM,sBAApB,GAA6C,UAAS/D,GAAT,EAAcf,QAAd,EAAwB;EACnE,IAAIyF,eAAe,GAAG,KAAKT,qBAAL,CAA2BjE,GAA3B,CAAtB;EACA,IAAId,MAAM,GAAG,KAAKyF,sBAAL,CAA4B,KAAKxC,kBAAjC,CAAb;EACA,IAAI3D,GAAG,GAAGU,MAAM,CAACG,eAAP,CAAuBqF,eAAvB,EAAwC,KAAK1F,UAA7C,EAAyD,KAAKO,cAA9D,EAA8EN,QAA9E,CAAV;EACA,IAAI,CAACT,GAAD,IAAQ,CAACS,QAAb,EAAuB,KAAKyD,gBAAL,CAAsB5B,IAAtB,CAA2B,4CACZ,KAAKvB,cADO,GACU,eADrC;EAEvB,OAAOf,GAAP;AACD,CAPD;;AASAf,SAAS,CAACgG,SAAV,CAAoBmB,uBAApB,GAA8C,UAAS5E,GAAT,EAAcf,QAAd,EAAwB;EACpE,IAAIyF,eAAe,GAAG,KAAKT,qBAAL,CAA2BjE,GAA3B,CAAtB;EACA,IAAId,MAAM,GAAG,KAAKyF,sBAAL,CAA4B,KAAKxC,kBAAjC,CAAb;EACA,KAAK5C,cAAL,GAAsBL,MAAM,CAACJ,YAAP,CAAoB4F,eAApB,EAAqC,KAAK1F,UAA1C,EAAsDC,QAAtD,CAAtB;AACD,CAJD;;AAMAxB,SAAS,CAACgG,SAAV,CAAoBkB,sBAApB,GAA6C,UAASE,IAAT,EAAe;EAC1D,IAAIC,IAAI,GAAGrH,SAAS,CAAC4F,mBAAV,CAA8BwB,IAA9B,CAAX;EACA,IAAIC,IAAJ,EAAU,OAAO,IAAIA,IAAJ,EAAP,CAAV,KACK,MAAM,IAAInB,KAAJ,CAAU,0BAA0BkB,IAA1B,GAAiC,oBAA3C,CAAN;AACN,CAJD;;AAMApH,SAAS,CAACgG,SAAV,CAAoBsB,6BAApB,GAAoD,UAASF,IAAT,EAAe;EACjE,IAAIC,IAAI,GAAGrH,SAAS,CAACsF,0BAAV,CAAqC8B,IAArC,CAAX;EACA,IAAIC,IAAJ,EAAU,OAAO,IAAIA,IAAJ,EAAP,CAAV,KACK,MAAM,IAAInB,KAAJ,CAAU,iCAAiCkB,IAAjC,GAAwC,oBAAlD,CAAN;AACN,CAJD;;AAMApH,SAAS,CAACgG,SAAV,CAAoBuB,iBAApB,GAAwC,UAASH,IAAT,EAAe;EACrD,IAAIC,IAAI,GAAGrH,SAAS,CAAC2F,cAAV,CAAyByB,IAAzB,CAAX;EACA,IAAIC,IAAJ,EAAU,OAAO,IAAIA,IAAJ,EAAP,CAAV,KACK,MAAM,IAAInB,KAAJ,CAAU,qBAAqBkB,IAArB,GAA4B,oBAAtC,CAAN;AACN,CAJD;;AAOApH,SAAS,CAACgG,SAAV,CAAoBK,kBAApB,GAAyC,UAAS9D,GAAT,EAAc;EACrD,KAAK,IAAIiF,CAAT,IAAc,KAAKhD,UAAnB,EAA+B;IAC7B,IAAI,CAAC,KAAKA,UAAL,CAAgBiD,cAAhB,CAA+BD,CAA/B,CAAL,EAAwC;IAExC,IAAIV,GAAG,GAAG,KAAKtC,UAAL,CAAgBgD,CAAhB,CAAV;IAEA,IAAIE,GAAG,GAAGZ,GAAG,CAACY,GAAJ,CAAQ,CAAR,KAAY,GAAZ,GAAkBZ,GAAG,CAACY,GAAJ,CAAQC,SAAR,CAAkB,CAAlB,CAAlB,GAAyCb,GAAG,CAACY,GAAvD;IACA,IAAIE,IAAI,GAAG,EAAX;;IAEA,IAAIF,GAAG,IAAE,EAAT,EAAa;MACXE,IAAI,GAAGvI,KAAK,CAACwI,MAAN,CAAa,KAAb,EAAoBtF,GAApB,CAAP;IACD,CAFD,MAGK,IAAImF,GAAG,CAACI,OAAJ,CAAY,GAAZ,KAAoB,CAAC,CAAzB,EAA4B;MAC/B;MACA,MAAM,IAAI5B,KAAJ,CAAU,6CAAV,CAAN;IACD,CAHI,MAIA;MACH,IAAI6B,SAAJ;MACA,IAAIC,mBAAmB,GAAG,CAA1B;;MACA,KAAK,IAAIC,KAAT,IAAkB,KAAK/C,YAAvB,EAAqC;QACnC,IAAI,CAAC,KAAKA,YAAL,CAAkBuC,cAAlB,CAAiCQ,KAAjC,CAAL,EAA8C;QAC9C,IAAIC,aAAa,GAAG,2BAA2B,KAAKhD,YAAL,CAAkB+C,KAAlB,CAA3B,GAAsD,MAAtD,GAA+DP,GAA/D,GAAqE,IAAzF;QACA,IAAIS,QAAQ,GAAG9I,KAAK,CAACwI,MAAN,CAAaK,aAAb,EAA4B3F,GAA5B,CAAf;QACAyF,mBAAmB,IAAIG,QAAQ,CAACrF,MAAhC;;QACA,IAAIqF,QAAQ,CAACrF,MAAT,GAAkB,CAAtB,EAAyB;UACvB8E,IAAI,GAAGO,QAAP;UACAJ,SAAS,GAAGG,aAAZ;QACD;MACF;;MACD,IAAIF,mBAAmB,GAAG,CAA1B,EAA6B;QACzB,MAAM,IAAI9B,KAAJ,CAAU,0EAChB,kEADgB,GAEhB,4BAFM,CAAN;MAGH;;MAEDY,GAAG,CAACzH,KAAJ,GAAY0I,SAAZ;IACD;;IAED,IAAIH,IAAI,CAAC9E,MAAL,IAAa,CAAjB,EAAoB;MAClB,KAAKmC,gBAAL,CAAsB5B,IAAtB,CAA2B,oEACTyD,GAAG,CAACY,GADK,GACC,6CAD5B;MAEA,OAAO,KAAP;IACD;;IAED,IAAIU,QAAQ,GAAG,KAAKvB,oBAAL,CAA0BtE,GAA1B,EAA+BuE,GAA/B,EAAoCc,IAAI,CAAC,CAAD,CAAxC,CAAf;IAEA,IAAIS,IAAI,GAAG,KAAKd,iBAAL,CAAuBT,GAAG,CAACwB,eAA3B,CAAX;IACA,IAAItH,MAAM,GAAGqH,IAAI,CAAC3H,OAAL,CAAa0H,QAAb,CAAb;;IAEA,IAAI,CAACG,mBAAmB,CAACvH,MAAD,EAAS8F,GAAG,CAAC0B,WAAb,CAAxB,EAAmD;MACjD,KAAKvD,gBAAL,CAAsB5B,IAAtB,CAA2B,gCAAgCyD,GAAG,CAACY,GAApC,GACD,wBADC,GAC2B1G,MAD3B,GAED,2CAFC,GAE6C8F,GAAG,CAAC0B,WAF5E;MAIA,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD,CA1DD;;AA4DA,SAASD,mBAAT,CAA6BvH,MAA7B,EAAqCyH,cAArC,EAAqD;EACnD,IAAIC,MAAJ,EAAYC,cAAZ;EAEA,IAAIC,YAAY,GAAG,UAAUC,IAAV,CAAeC,OAAO,CAACC,OAAvB,EAAgC,CAAhC,CAAnB;;EAEA,IAAI,CAACH,YAAD,IAAiB,CAArB,EAAwB;IACtBF,MAAM,GAAGM,MAAM,CAACC,IAAP,CAAYjI,MAAZ,EAAoB,QAApB,CAAT;IACA2H,cAAc,GAAGK,MAAM,CAACC,IAAP,CAAYR,cAAZ,EAA4B,QAA5B,CAAjB;EACD,CAHD,MAGO;IACL;IACAC,MAAM,GAAG,IAAIM,MAAJ,CAAWhI,MAAX,EAAmB,QAAnB,CAAT;IACA2H,cAAc,GAAG,IAAIK,MAAJ,CAAWP,cAAX,EAA2B,QAA3B,CAAjB;EACD;;EAED,IAAI,OAAOC,MAAM,CAACQ,MAAd,KAAyB,UAA7B,EAAyC;IACvC,OAAOR,MAAM,CAACQ,MAAP,CAAcP,cAAd,CAAP;EACD,CAhBkD,CAkBnD;;;EACA,IAAID,MAAM,CAAC5F,MAAP,KAAkB6F,cAAc,CAAC7F,MAArC,EAA6C;IAC3C,OAAO,KAAP;EACD;;EAED,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwF,MAAM,CAAC5F,MAA3B,EAAmCI,CAAC,EAApC,EAAwC;IACtC,IAAIwF,MAAM,CAACxF,CAAD,CAAN,KAAcyF,cAAc,CAACzF,CAAD,CAAhC,EAAqC;MACnC,OAAO,KAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD;;AAEDlD,SAAS,CAACgG,SAAV,CAAoBmD,aAApB,GAAoC,UAASpE,aAAT,EAAwB;EAC1D,IAAI,OAAOA,aAAP,KAAyB,QAA7B,EAAuC;IACrC,KAAKA,aAAL,GAAqBA,aAAa,GAAG,IAAIxF,GAAJ,GAAU6G,eAAV,CAA0BrB,aAA1B,CAArC;EACD,CAFD,MAEO;IACL,KAAKA,aAAL,GAAqBA,aAArB;EACD;;EAED,KAAKD,YAAL,GAAoBC,aAAa,CAACqE,QAAd,EAApB;EAEA,IAAIC,KAAK,GAAGhK,KAAK,CAACwI,MAAN,CAAa,yDAAb,EAAwE9C,aAAxE,CAAZ;EACA,IAAIsE,KAAK,CAACvG,MAAN,IAAc,CAAlB,EAAqB,MAAM,IAAIoD,KAAJ,CAAU,0DAAV,CAAN;EACrB,KAAKtB,yBAAL,GAAiCyE,KAAK,CAAC,CAAD,CAAL,CAASC,KAA1C;EAEA,KAAK5E,kBAAL,GACEjF,KAAK,CAAC8J,SAAN,CAAgBxE,aAAhB,EAA+B,kDAA/B,EAAmFuE,KADrF;EAGA,KAAK9E,UAAL,GAAkB,EAAlB;EACA,IAAIA,UAAU,GAAGnF,KAAK,CAACwI,MAAN,CAAa,+DAAb,EAA8E9C,aAA9E,CAAjB;EACA,IAAIP,UAAU,CAAC1B,MAAX,IAAqB,CAAzB,EAA4B,MAAM,IAAIoD,KAAJ,CAAU,uCAAV,CAAN;;EAE5B,KAAK,IAAIhD,CAAT,IAAcsB,UAAd,EAA0B;IACxB,IAAI,CAACA,UAAU,CAACiD,cAAX,CAA0BvE,CAA1B,CAAL,EAAmC;IAEnC,KAAKsG,aAAL,CAAmBhF,UAAU,CAACtB,CAAD,CAA7B;EACD;;EAED,KAAKpB,cAAL,GACErC,KAAK,CAAC8J,SAAN,CAAgBxE,aAAhB,EAA+B,6CAA/B,EAA8E0E,IAA9E,CAAmF3F,OAAnF,CAA2F,QAA3F,EAAqG,EAArG,CADF;EAGA,KAAKvD,OAAL,GAAelB,KAAK,CAACwI,MAAN,CAAa,+BAAb,EAA8C9C,aAA9C,CAAf;AACD,CA9BD;AAgCA;AACA;AACA;AACA;;;AACA/E,SAAS,CAACgG,SAAV,CAAoBwD,aAApB,GAAoC,UAAS1C,GAAT,EAAc;EAChD,IAAIuC,KAAK,GAAG5J,KAAK,CAACgH,UAAN,CAAiBK,GAAjB,EAAsB,cAAtB,CAAZ;EACA,IAAIuC,KAAK,CAACvG,MAAN,IAAc,CAAlB,EAAqB,MAAM,IAAIoD,KAAJ,CAAU,8CAA8CY,GAAG,CAACsC,QAAJ,EAAxD,CAAN;EACrB,IAAIM,cAAc,GAAGL,KAAK,CAAC,CAAD,CAA1B;EAEA,IAAIlF,IAAI,GAAG1E,KAAK,CAACkK,QAAN,CAAeD,cAAf,EAA+B,WAA/B,CAAX;EACA,IAAI,CAACvF,IAAL,EAAW,MAAM,IAAI+B,KAAJ,CAAU,gDAAgDwD,cAAc,CAACN,QAAf,EAA1D,CAAN;EACX,IAAIQ,UAAU,GAAGzF,IAAI,CAACmF,KAAtB;EAEAD,KAAK,GAAG5J,KAAK,CAACgH,UAAN,CAAiBK,GAAjB,EAAsB,aAAtB,CAAR;EACA,IAAIuC,KAAK,CAACvG,MAAN,IAAc,CAAlB,EAAqB,MAAM,IAAIoD,KAAJ,CAAU,kDAAkDY,GAAG,CAACsC,QAAJ,EAA5D,CAAN;;EACrB,IAAIC,KAAK,CAAC,CAAD,CAAL,CAASQ,UAAT,CAAoB/G,MAApB,IAA4B,CAA5B,IAAiC,CAACuG,KAAK,CAAC,CAAD,CAAL,CAASS,UAAT,CAAoBL,IAA1D,EACA;IACE,MAAM,IAAIvD,KAAJ,CAAU,gDAAgDmD,KAAK,CAAC,CAAD,CAAL,CAASD,QAAT,EAA1D,CAAN;EACD;;EACD,IAAIZ,WAAW,GAAGa,KAAK,CAAC,CAAD,CAAL,CAASS,UAAT,CAAoBL,IAAtC;EAEA,IAAI1C,UAAU,GAAG,EAAjB;EACA,IAAIC,6BAAJ;EACAqC,KAAK,GAAG5J,KAAK,CAACgH,UAAN,CAAiBK,GAAjB,EAAsB,YAAtB,CAAR;;EACA,IAAIuC,KAAK,CAACvG,MAAN,IAAc,CAAlB,EAAqB;IACnB,IAAIiH,cAAc,GAAGV,KAAK,CAAC,CAAD,CAA1B;IACA,IAAIW,aAAa,GAAGvK,KAAK,CAACgH,UAAN,CAAiBsD,cAAjB,EAAiC,WAAjC,CAApB;;IACA,KAAK,IAAIE,CAAT,IAAcD,aAAd,EAA6B;MAC3B,IAAI,CAACA,aAAa,CAACvC,cAAd,CAA6BwC,CAA7B,CAAL,EAAsC;MAEtC,IAAIC,KAAK,GAAGF,aAAa,CAACC,CAAD,CAAzB;MACAlD,UAAU,CAAC1D,IAAX,CAAgB5D,KAAK,CAACkK,QAAN,CAAeO,KAAf,EAAsB,WAAtB,EAAmCZ,KAAnD;IACD;;IAED,IAAIa,mBAAmB,GAAG1K,KAAK,CAACgH,UAAN,CAAiByD,KAAjB,EAAwB,qBAAxB,CAA1B;;IACA,IAAIC,mBAAmB,CAACrH,MAApB,GAA6B,CAAjC,EAAoC;MAClC;MACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAACiH,mBAAmB,CAACrH,MAAtC,EAA8CI,CAAC,EAA/C,EAAmD;QACjD,IAAI8D,6BAAJ,EAAmC;UACjCA,6BAA6B,GAAGA,6BAA6B,GAAG,GAAhC,GAAsCmD,mBAAmB,CAACjH,CAAD,CAAnB,CAAuBkH,YAAvB,CAAoC,YAApC,CAAtE;QACD,CAFD,MAEO;UACLpD,6BAA6B,GAAGmD,mBAAmB,CAACjH,CAAD,CAAnB,CAAuBkH,YAAvB,CAAoC,YAApC,CAAhC;QACD;MACF;IACF;EACF;;EAED,IAAIC,qBAAqB,GAAIzH,KAAK,CAACC,OAAN,CAAc,KAAKwC,kBAAnB,KAA0C,KAAKA,kBAAL,CAAwBvC,MAAxB,GAAiC,CAAxG;;EACA,IAAGuH,qBAAH,EAAyB;IACvB,KAAKhF,kBAAL,CAAwBiF,OAAxB,CAAgC,UAASL,CAAT,EAAW;MACzClD,UAAU,CAAC1D,IAAX,CAAgB4G,CAAhB;IACD,CAFD;EAGD;EAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,IAAIlD,UAAU,CAACjE,MAAX,KAAsB,CAAtB,IAA2BiE,UAAU,CAACA,UAAU,CAACjE,MAAX,GAAoB,CAArB,CAAV,KAAsC,uDAArE,EAA8H;IAC1HiE,UAAU,CAAC1D,IAAX,CAAgB,iDAAhB;EACH;;EAED,KAAKkH,YAAL,CAAkB,IAAlB,EAAwBxD,UAAxB,EAAoC6C,UAApC,EAAgDnK,KAAK,CAACkK,QAAN,CAAe7C,GAAf,EAAoB,KAApB,EAA2BwC,KAA3E,EAAkFd,WAAlF,EAA+FxB,6BAA/F,EAA8H,KAA9H;AACD,CAhED;;AAkEAhH,SAAS,CAACgG,SAAV,CAAoBuE,YAApB,GAAmC,UAASlL,KAAT,EAAgB0H,UAAhB,EAA4BuB,eAA5B,EAA6CZ,GAA7C,EAAkDc,WAAlD,EAA+DxB,6BAA/D,EAA8FwD,UAA9F,EAA0G;EAC3I,KAAKhG,UAAL,CAAgBnB,IAAhB,CAAqB;IACnB,SAAShE,KADU;IAEnB,cAAc0H,UAAU,GAAGA,UAAH,GAAgB,CAAC,yCAAD,CAFrB;IAGnB,mBAAmBuB,eAAe,GAAGA,eAAH,GAAqB,wCAHpC;IAInB,OAAOZ,GAJY;IAKnB,eAAec,WALI;IAMnB,iCAAiCxB,6BANd;IAOnB,cAAcwD;EAPK,CAArB;AASD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxK,SAAS,CAACgG,SAAV,CAAoByE,gBAApB,GAAuC,UAAS9J,GAAT,EAAc+J,IAAd,EAAoBlJ,QAApB,EAA8B;EACnE,IAAI,OAAOkJ,IAAP,KAAgB,UAAhB,IAA8BlJ,QAAQ,IAAI,IAA9C,EAAoD;IAClDA,QAAQ,GAAGkJ,IAAX;EACD;;EAED,IAAIlJ,QAAQ,IAAI,IAAZ,IAAoB,OAAOA,QAAP,KAAoB,UAA5C,EAAwD;IACtD,MAAM,IAAI0E,KAAJ,CAAU,4CAAV,CAAN;EACD;;EAED,IAAI3D,GAAG,GAAG,IAAIhD,GAAJ,GAAU6G,eAAV,CAA0BzF,GAA1B,CAAV;EAAA,IACIgK,SAAS,GAAG,OADhB;EAAA,IAEIC,cAAc,GAAG,EAFrB;EAAA,IAGIC,QAHJ;EAAA,IAIIC,KAJJ;EAAA,IAKIzK,MALJ;EAAA,IAMI0K,aANJ;EAQA,IAAIC,YAAY,GAAG,CAAC,QAAD,EAAW,SAAX,EAAsB,QAAtB,EAAgC,OAAhC,CAAnB;EAEAN,IAAI,GAAGA,IAAI,IAAI,EAAf;EACArK,MAAM,GAAGqK,IAAI,CAACrK,MAAd;EACAyK,KAAK,GAAGJ,IAAI,CAACI,KAAL,IAAc,EAAtB;EACAD,QAAQ,GAAGH,IAAI,CAACG,QAAL,IAAiB,EAA5B;EACA,IAAII,gBAAgB,GAAGP,IAAI,CAACO,gBAAL,IAAyB,EAAhD;EAEA,KAAKxI,iBAAL,GAAyB;IACvByI,kBAAkB,EAAE,UAAS7K,MAAT,EAAiB;MACnC,OAAO4K,gBAAgB,CAAC5K,MAAD,CAAvB;IACD;EAHsB,CAAzB,CAzBmE,CA+BnE;;EACAwK,QAAQ,CAACM,SAAT,GAAqBN,QAAQ,CAACM,SAAT,IAAsB,IAA3C,CAhCmE,CAiCnE;;EACAN,QAAQ,CAACO,MAAT,GAAkBP,QAAQ,CAACO,MAAT,IAAmB,QAArC;;EAEA,IAAIJ,YAAY,CAAClD,OAAb,CAAqB+C,QAAQ,CAACO,MAA9B,MAA0C,CAAC,CAA/C,EAAkD;IAChD,IAAIjF,GAAG,GAAG,IAAID,KAAJ,CAAU,mDAAmD2E,QAAQ,CAACO,MAA5D,GAClB,yCADkB,GAC0BJ,YAAY,CAACK,IAAb,CAAkB,IAAlB,CADpC,CAAV;;IAEA,IAAI,CAAC7J,QAAL,EAAe;MACb,MAAM2E,GAAN;IACD,CAFD,MAEO;MACL3E,QAAQ,CAAC2E,GAAD,EAAM,IAAN,CAAR;MACA;IACD;EACF,CA7CkE,CA+CnE;;;EACA,IAAI9F,MAAJ,EAAY;IACVsK,SAAS,IAAI,MAAMtK,MAAnB;IACA0K,aAAa,GAAG1K,MAAM,GAAG,GAAzB;EACD,CAHD,MAGO;IACL0K,aAAa,GAAG,EAAhB;EACD;;EAEDO,MAAM,CAACC,IAAP,CAAYT,KAAZ,EAAmBR,OAAnB,CAA2B,UAASlD,IAAT,EAAe;IACxC,IAAIA,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKuD,SAAjC,EAA4C;MAC1CC,cAAc,CAACvH,IAAf,CAAoB+D,IAAI,GAAG,KAAP,GAAe0D,KAAK,CAAC1D,IAAD,CAApB,GAA6B,IAAjD;IACD;EACF,CAJD,EAvDmE,CA6DnE;;EACAwD,cAAc,CAACvH,IAAf,CAAoBsH,SAAS,GAAG,yCAAhC;EAEA,IAAI7F,YAAY,GAAG,MAAMiG,aAAN,GAAsB,YAAtB,GAAqCH,cAAc,CAACS,IAAf,CAAoB,GAApB,CAArC,GAAgE,GAAnF;EAEAvG,YAAY,IAAI,KAAK0G,gBAAL,CAAsBjJ,GAAtB,EAA2BlC,MAA3B,CAAhB;EACAyE,YAAY,IAAI,KAAK3E,UAAL,CAAgBE,MAAhB,CAAhB;EACAyE,YAAY,IAAI,OAAOiG,aAAP,GAAuB,YAAvC;EAEA,KAAK/F,kBAAL,GAA0BzC,GAAG,CAAC6G,QAAJ,EAA1B;EAEA,IAAIqC,sBAAsB,GAAG,EAA7B;EACAH,MAAM,CAACC,IAAP,CAAYN,gBAAZ,EAA8BX,OAA9B,CAAsC,UAASlK,GAAT,EAAc;IAClDqL,sBAAsB,IAAI,WAAWrL,GAAX,GAAiB,IAAjB,GAAwB6K,gBAAgB,CAAC7K,GAAD,CAAxC,GAAgD,IAA1E;EACD,CAFD,EAzEmE,CA6EnE;EACA;;EACA,IAAIsL,qBAAqB,GAAG,YAAYD,sBAAZ,GAAqC,GAArC,GAA2C3G,YAA3C,GAA0D,UAAtF;EACA,IAAInE,GAAG,GAAG,IAAIpB,GAAJ,GAAU6G,eAAV,CAA0BsF,qBAA1B,CAAV;EACA,IAAIC,YAAY,GAAGhL,GAAG,CAACiL,eAAJ,CAAoB9B,UAAvC;EAEA,IAAI+B,aAAa,GAAGxM,KAAK,CAACwI,MAAN,CAAagD,QAAQ,CAACM,SAAtB,EAAiC5I,GAAjC,CAApB;;EAEA,IAAI,CAACsJ,aAAD,IAAkBA,aAAa,CAAC/I,MAAd,KAAyB,CAA/C,EAAkD;IAChD,IAAIqD,GAAG,GAAG,IAAID,KAAJ,CAAU,kEAAkE2E,QAAQ,CAACM,SAArF,CAAV;;IACA,IAAI,CAAC3J,QAAL,EAAe;MACb,MAAM2E,GAAN;IACD,CAFD,MAEO;MACL3E,QAAQ,CAAC2E,GAAD,EAAM,IAAN,CAAR;MACA;IACD;EACF;;EAED0F,aAAa,GAAGA,aAAa,CAAC,CAAD,CAA7B;;EAEA,IAAIhB,QAAQ,CAACO,MAAT,KAAoB,QAAxB,EAAkC;IAChCS,aAAa,CAACC,WAAd,CAA0BH,YAA1B;EACD,CAFD,MAEO,IAAId,QAAQ,CAACO,MAAT,KAAoB,SAAxB,EAAmC;IACxCS,aAAa,CAACE,YAAd,CAA2BJ,YAA3B,EAAyCE,aAAa,CAAC/B,UAAvD;EACD,CAFM,MAEA,IAAIe,QAAQ,CAACO,MAAT,KAAoB,QAAxB,EAAkC;IACvCS,aAAa,CAAC3H,UAAd,CAAyB6H,YAAzB,CAAsCJ,YAAtC,EAAoDE,aAApD;EACD,CAFM,MAEA,IAAIhB,QAAQ,CAACO,MAAT,KAAoB,OAAxB,EAAiC;IACtCS,aAAa,CAAC3H,UAAd,CAAyB6H,YAAzB,CAAsCJ,YAAtC,EAAoDE,aAAa,CAACG,WAAlE;EACD;;EAED,KAAKjH,aAAL,GAAqB4G,YAArB;EACA,IAAIM,cAAc,GAAGxM,KAAK,CAACgH,UAAN,CAAiB,KAAK1B,aAAtB,EAAqC,YAArC,CAArB;;EACA,IAAIkH,cAAc,CAACnJ,MAAf,IAAyB,CAA7B,EAAgC;IAC9B,IAAIqD,GAAG,GAAG,IAAID,KAAJ,CAAU,kDAAV,CAAV;;IACA,IAAI,CAAC1E,QAAL,EAAe;MACb,MAAM2E,GAAN;IACD,CAFD,MAEO;MACL3E,QAAQ,CAAC2E,GAAD,CAAR;MACA;IACD;EACF;;EACD8F,cAAc,GAAGA,cAAc,CAAC,CAAD,CAA/B;;EAEA,IAAI,CAACzK,QAAL,EAAe;IACb;IACA,KAAK2F,uBAAL,CAA6B5E,GAA7B;IACAoJ,YAAY,CAACI,YAAb,CAA0B,KAAKG,eAAL,CAAqB7L,MAArB,CAA1B,EAAwD4L,cAAc,CAACD,WAAvE;IACA,KAAKlH,YAAL,GAAoB6G,YAAY,CAACvC,QAAb,EAApB;IACA,KAAKvE,SAAL,GAAiBtC,GAAG,CAAC6G,QAAJ,EAAjB;EACD,CAND,MAMO;IACL,IAAI+C,IAAI,GAAG,IAAX,CADK,CAEL;;IACA,KAAKhF,uBAAL,CAA6B5E,GAA7B,EAAkC,UAAS4D,GAAT,EAAciG,SAAd,EAAyB;MACzD,IAAIjG,GAAJ,EAAS;QACP3E,QAAQ,CAAC2E,GAAD,CAAR;MACD,CAFD,MAEO;QACLgG,IAAI,CAACrK,cAAL,GAAsBsK,SAAtB;QACAT,YAAY,CAACI,YAAb,CAA0BI,IAAI,CAACD,eAAL,CAAqB7L,MAArB,CAA1B,EAAwD4L,cAAc,CAACD,WAAvE;QACAG,IAAI,CAACrH,YAAL,GAAoB6G,YAAY,CAACvC,QAAb,EAApB;QACA+C,IAAI,CAACtH,SAAL,GAAiBtC,GAAG,CAAC6G,QAAJ,EAAjB;QACA5H,QAAQ,CAAC,IAAD,EAAO2K,IAAP,CAAR;MACD;IACF,CAVD;EAWD;AACF,CA7ID;;AA+IAnM,SAAS,CAACgG,SAAV,CAAoB7F,UAApB,GAAiC,UAASE,MAAT,EAAiB;EAChD,IAAIU,GAAG,GAAG,EAAV;EACA,IAAIgK,aAAJ;EAEAA,aAAa,GAAG1K,MAAM,IAAI,EAA1B;EACA0K,aAAa,GAAGA,aAAa,GAAGA,aAAa,GAAG,GAAnB,GAAyBA,aAAtD;;EAEA,IAAI,KAAKpG,eAAT,EAA0B;IACxB5D,GAAG,IAAI,MAAMgK,aAAN,GAAsB,UAA7B;IACAhK,GAAG,IAAI,KAAK4D,eAAL,CAAqBxE,UAArB,CAAgC,KAAKoB,UAArC,EAAiDlB,MAAjD,CAAP;IACAU,GAAG,IAAI,OAAOgK,aAAP,GAAuB,UAA9B;EACD;;EACD,OAAOhK,GAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;;;AACAf,SAAS,CAACgG,SAAV,CAAoBqG,gBAApB,GAAuC,UAAS9J,GAAT,EAAclC,MAAd,EAAsB;EAE3D,IAAIU,GAAG,GAAG,EAAV;EAEAV,MAAM,GAAGA,MAAM,IAAI,EAAnB;EACAA,MAAM,GAAGA,MAAM,GAAGA,MAAM,GAAG,GAAZ,GAAkBA,MAAjC;;EAEA,KAAK,IAAIiM,CAAT,IAAc,KAAK9H,UAAnB,EAA+B;IAC7B,IAAI,CAAC,KAAKA,UAAL,CAAgBiD,cAAhB,CAA+B6E,CAA/B,CAAL,EAAwC;IAExC,IAAIxF,GAAG,GAAG,KAAKtC,UAAL,CAAgB8H,CAAhB,CAAV;IAAA,IACIjD,KAAK,GAAGhK,KAAK,CAACsD,kBAAN,CAAyBmE,GAAG,CAACzH,KAA7B,EAAoCkD,GAApC,EAAyC,KAAKE,iBAA9C,CADZ;;IAGA,IAAI4G,KAAK,CAACvG,MAAN,IAAc,CAAlB,EAAqB;MACnB,MAAM,IAAIoD,KAAJ,CAAU,oEAAoEY,GAAG,CAACzH,KAAlF,CAAN;IACD;;IAED,KAAK,IAAIkN,CAAT,IAAclD,KAAd,EAAqB;MACnB,IAAI,CAACA,KAAK,CAAC5B,cAAN,CAAqB8E,CAArB,CAAL,EAA8B;MAE9B,IAAIxI,IAAI,GAAGsF,KAAK,CAACkD,CAAD,CAAhB;;MACA,IAAIzF,GAAG,CAAC0D,UAAR,EAAoB;QAClBzJ,GAAG,IAAI,MAAMV,MAAN,GAAe,qBAAtB;MACD,CAFD,MAGK;QACH,IAAIoE,EAAE,GAAG,KAAK+H,WAAL,CAAiBzI,IAAjB,CAAT;QACA+C,GAAG,CAACY,GAAJ,GAAUjD,EAAV;QACA1D,GAAG,IAAI,MAAMV,MAAN,GAAe,mBAAf,GAAqCoE,EAArC,GAA0C,KAAjD;MACD;;MACD1D,GAAG,IAAI,MAAMV,MAAN,GAAe,aAAtB;;MACA,KAAK,IAAI4J,CAAT,IAAcnD,GAAG,CAACC,UAAlB,EAA8B;QAC5B,IAAI,CAACD,GAAG,CAACC,UAAJ,CAAeU,cAAf,CAA8BwC,CAA9B,CAAL,EAAuC;QAEvC,IAAIC,KAAK,GAAGpD,GAAG,CAACC,UAAJ,CAAekD,CAAf,CAAZ;QACA,IAAIwC,SAAS,GAAG,KAAKnF,6BAAL,CAAmC4C,KAAnC,CAAhB;QACAnJ,GAAG,IAAI,MAAMV,MAAN,GAAe,wBAAf,GAA0CoM,SAAS,CAACxL,gBAAV,EAA1C,GAAyE,OAAhF;MACD;;MAED,IAAImH,QAAQ,GAAG,KAAKvB,oBAAL,CAA0BtE,GAA1B,EAA+BuE,GAA/B,EAAoC/C,IAApC,CAAf;MAEA,IAAIuE,eAAe,GAAG,KAAKf,iBAAL,CAAuBT,GAAG,CAACwB,eAA3B,CAAtB;MACAvH,GAAG,IAAI,OAAOV,MAAP,GAAgB,aAAhB,GACA,GADA,GACMA,MADN,GACe,2BADf,GAC6CiI,eAAe,CAACrH,gBAAhB,EAD7C,GACkF,OADlF,GAEC,GAFD,GAEOZ,MAFP,GAEgB,cAFhB,GAEiCiI,eAAe,CAAC5H,OAAhB,CAAwB0H,QAAxB,CAFjC,GAEqE,IAFrE,GAE4E/H,MAF5E,GAEqF,cAFrF,GAGC,IAHD,GAGQA,MAHR,GAGiB,YAHxB;IAID;EACF;;EAED,OAAOU,GAAP;AACD,CAjDD;;AAmDAf,SAAS,CAACgG,SAAV,CAAoBY,WAApB,GAAkC,UAASG,UAAT,EAAqBhD,IAArB,EAA2BQ,OAA3B,EAAoC;EACpEA,OAAO,GAAGA,OAAO,IAAI,EAArB;EACAA,OAAO,CAACuB,kBAAR,GAA6BvB,OAAO,CAACuB,kBAAR,IAA8B9F,SAAS,CAAC8F,kBAArE;EACAvB,OAAO,CAACQ,aAAR,GAAwB,KAAKA,aAA7B;EAEA,IAAIqD,QAAQ,GAAGrE,IAAI,CAAC2I,SAAL,CAAe,IAAf,CAAf,CALoE,CAKhC;;EAEpC,KAAK,IAAIzC,CAAT,IAAclD,UAAd,EAA0B;IACxB,IAAI,CAACA,UAAU,CAACU,cAAX,CAA0BwC,CAA1B,CAAL,EAAmC;IAEnC,IAAIwC,SAAS,GAAG,KAAKnF,6BAAL,CAAmCP,UAAU,CAACkD,CAAD,CAA7C,CAAhB;IACA7B,QAAQ,GAAGqE,SAAS,CAAC3D,OAAV,CAAkBV,QAAlB,EAA4B7D,OAA5B,CAAX,CAJwB,CAKxB;IACA;IACA;IACA;IACA;IACA;IACA;EACD;;EACD,OAAO6D,QAAQ,CAACgB,QAAT,EAAP;AACD,CArBD;AAuBA;AACA;AACA;AACA;;;AACApJ,SAAS,CAACgG,SAAV,CAAoBwG,WAApB,GAAkC,UAASzI,IAAT,EAAe;EAC/C,IAAII,IAAJ;;EAEA,IAAI,KAAKG,MAAL,IAAa,YAAjB,EAA+B;IAC7BH,IAAI,GAAG1E,KAAK,CAACkK,QAAN,CAAe5F,IAAf,EACL,IADK,EAEL,oFAFK,CAAP;EAGD,CAJD,MAKK;IACH,KAAK,IAAIkE,KAAT,IAAkB,KAAK/C,YAAvB,EAAqC;MACnC,IAAI,CAAC,KAAKA,YAAL,CAAkBuC,cAAlB,CAAiCQ,KAAjC,CAAL,EAA8C;MAE9C9D,IAAI,GAAG1E,KAAK,CAACkK,QAAN,CAAe5F,IAAf,EAAqB,KAAKmB,YAAL,CAAkB+C,KAAlB,CAArB,EAA+C,IAA/C,CAAP;MACA,IAAI9D,IAAJ,EAAU;IACX;EACF;;EAED,IAAIA,IAAJ,EAAU,OAAOA,IAAI,CAACmF,KAAZ,CAjBqC,CAmB/C;;EACA,IAAI7E,EAAE,GAAG,MAAM,KAAKA,EAAL,EAAf;;EAEA,IAAI,KAAKH,MAAL,IAAa,YAAjB,EAA+B;IAC7BP,IAAI,CAAC4I,cAAL,CAAoB,+BAApB,EACE,WADF,EAEE,oFAFF;IAGA5I,IAAI,CAAC4I,cAAL,CAAoB,oFAApB,EACE,QADF,EAEElI,EAFF;EAGD,CAPD,MAQK;IACJV,IAAI,CAAC6I,YAAL,CAAkB,IAAlB,EAAwBnI,EAAxB;EACA;;EAED,OAAOA,EAAP;AACD,CAnCD;AAqCA;AACA;AACA;AACA;;;AACAzE,SAAS,CAACgG,SAAV,CAAoBwF,gBAApB,GAAuC,UAASjJ,GAAT,EAAclC,MAAd,EAAsB;EAC3D,IAAIoM,SAAS,GAAG,KAAKnF,6BAAL,CAAmC,KAAK1C,yBAAxC,CAAhB;EACA,IAAIyC,IAAI,GAAG,KAAKH,sBAAL,CAA4B,KAAKxC,kBAAjC,CAAX;EACA,IAAIqG,aAAJ;EAEAA,aAAa,GAAG1K,MAAM,IAAI,EAA1B;EACA0K,aAAa,GAAGA,aAAa,GAAGA,aAAa,GAAG,GAAnB,GAAyBA,aAAtD;EAEA,IAAIhK,GAAG,GAAG,MAAMgK,aAAN,GAAsB,aAAhC;EACAhK,GAAG,IAAI,MAAMgK,aAAN,GAAsB,qCAAtB,GAA8D0B,SAAS,CAACxL,gBAAV,EAA9D,GAA6F,OAA7F,GACC,GADD,GACO8J,aADP,GACuB,8BADvB,GACwD1D,IAAI,CAACpG,gBAAL,EADxD,GACkF,OADzF;EAGAF,GAAG,IAAI,KAAKsL,gBAAL,CAAsB9J,GAAtB,EAA2BlC,MAA3B,CAAP;EACAU,GAAG,IAAI,OAAOgK,aAAP,GAAuB,aAA9B;EACA,OAAOhK,GAAP;AACD,CAfD;AAiBA;AACA;AACA;AACA;;;AACAf,SAAS,CAACgG,SAAV,CAAoBkG,eAApB,GAAsC,UAAS7L,MAAT,EAAiB;EACrD,IAAIsK,SAAS,GAAG,OAAhB;;EAEA,IAAItK,MAAJ,EAAY;IACVsK,SAAS,IAAI,MAAMtK,MAAnB;IACAA,MAAM,IAAI,GAAV;EACD,CAHD,MAGO;IACLA,MAAM,GAAG,EAAT;EACD;;EAED,IAAIwM,iBAAiB,GAAG,MAAMxM,MAAN,GAAe,iBAAf,GAAmC,KAAKyB,cAAxC,GAAyD,IAAzD,GAAgEzB,MAAhE,GAAyE,iBAAjG,CAVqD,CAWrD;EACA;;EACA,IAAIqL,qBAAqB,GAAG,MAAMrL,MAAN,GAAe,YAAf,GAA8BsK,SAA9B,GAA0C,0CAA1C,GACAkC,iBADA,GAEA,IAFA,GAEOxM,MAFP,GAEgB,YAF5C;EAIA,IAAIkC,GAAG,GAAG,IAAIhD,GAAJ,GAAU6G,eAAV,CAA0BsF,qBAA1B,CAAV;EACA,OAAOnJ,GAAG,CAACqJ,eAAJ,CAAoB9B,UAA3B;AACD,CAnBD;;AAsBA9J,SAAS,CAACgG,SAAV,CAAoB8G,eAApB,GAAsC,YAAW;EAC/C,OAAO,KAAKhI,YAAZ;AACD,CAFD;;AAIA9E,SAAS,CAACgG,SAAV,CAAoB+G,qBAApB,GAA4C,YAAW;EACrD,OAAO,KAAK/H,kBAAZ;AACD,CAFD;;AAIAhF,SAAS,CAACgG,SAAV,CAAoBgH,YAApB,GAAmC,YAAW;EAC5C,OAAO,KAAKnI,SAAZ;AACD,CAFD"},"metadata":{},"sourceType":"script"}