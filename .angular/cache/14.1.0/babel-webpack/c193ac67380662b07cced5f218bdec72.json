{"ast":null,"code":"\"use strict\";\n/*\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\n * MIT Licensed\n *\n */\n\n/*jshint proto:true*/\n\nexports.__esModule = true;\nexports.open_wsdl = exports.WSDL = void 0;\n\nvar assert_1 = require(\"assert\");\n\nvar debugBuilder = require(\"debug\");\n\nvar fs = require(\"fs\");\n\nvar _ = require(\"lodash\");\n\nvar path = require(\"path\");\n\nvar sax = require(\"sax\");\n\nvar stripBom = require(\"strip-bom\");\n\nvar url = require(\"url\");\n\nvar http_1 = require(\"../http\");\n\nvar nscontext_1 = require(\"../nscontext\");\n\nvar utils_1 = require(\"../utils\");\n\nvar elements = require(\"./elements\");\n\nvar debug = debugBuilder('node-soap');\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar trimLeft = /^[\\s\\xA0]+/;\nvar trimRight = /[\\s\\xA0]+$/;\n\nfunction trim(text) {\n  return text.replace(trimLeft, '').replace(trimRight, '');\n}\n\nfunction deepMerge(destination, source) {\n  return _.mergeWith(destination, source, function (a, b) {\n    return Array.isArray(a) ? a.concat(b) : undefined;\n  });\n}\n\nfunction appendColon(ns) {\n  return ns && ns.charAt(ns.length - 1) !== ':' ? ns + ':' : ns;\n}\n\nfunction noColonNameSpace(ns) {\n  return ns && ns.charAt(ns.length - 1) === ':' ? ns.substring(0, ns.length - 1) : ns;\n}\n\nvar WSDL =\n/** @class */\nfunction () {\n  function WSDL(definition, uri, options) {\n    var _this = this;\n\n    this.ignoredNamespaces = ['tns', 'targetNamespace', 'typedNamespace'];\n    this.ignoreBaseNameSpaces = false;\n    this.valueKey = '$value';\n    this.xmlKey = '$xml';\n    var fromFunc;\n    this.uri = uri;\n\n    this.callback = function () {};\n\n    this._includesWsdl = []; // initialize WSDL cache\n\n    this.WSDL_CACHE = {};\n\n    if (options && options.WSDL_CACHE) {\n      this.WSDL_CACHE = options.WSDL_CACHE;\n    }\n\n    this._initializeOptions(options);\n\n    if (typeof definition === 'string') {\n      definition = stripBom(definition);\n      fromFunc = this._fromXML;\n    } else if (typeof definition === 'object') {\n      fromFunc = this._fromServices;\n    } else {\n      throw new Error('WSDL constructor takes either an XML string or service definition');\n    }\n\n    process.nextTick(function () {\n      try {\n        fromFunc.call(_this, definition);\n      } catch (e) {\n        return _this.callback(e);\n      }\n\n      _this.processIncludes(function (err) {\n        var name;\n\n        if (err) {\n          return _this.callback(err);\n        }\n\n        try {\n          _this.definitions.deleteFixedAttrs();\n\n          var services = _this.services = _this.definitions.services;\n\n          if (services) {\n            for (name in services) {\n              services[name].postProcess(_this.definitions);\n            }\n          }\n\n          var complexTypes = _this.definitions.complexTypes;\n\n          if (complexTypes) {\n            for (name in complexTypes) {\n              complexTypes[name].deleteFixedAttrs();\n            }\n          } // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\n\n\n          var bindings = _this.definitions.bindings;\n\n          for (var bindingName in bindings) {\n            var binding = bindings[bindingName];\n\n            if (typeof binding.style === 'undefined') {\n              binding.style = 'document';\n            }\n\n            var methods = binding.methods;\n            var topEls = binding.topElements = {};\n\n            for (var methodName in methods) {\n              if ((methods[methodName].style || binding.style) !== 'document') {\n                continue;\n              }\n\n              if (methods[methodName].input) {\n                var inputName = methods[methodName].input.$name;\n                var outputName = '';\n\n                if (methods[methodName].output) {\n                  outputName = methods[methodName].output.$name;\n                }\n\n                topEls[inputName] = {\n                  methodName: methodName,\n                  outputName: outputName\n                };\n              }\n            }\n          } // prepare soap envelope xmlns definition string\n\n\n          _this.xmlnsInEnvelope = _this._xmlnsMap();\n\n          _this.callback(err, _this);\n        } catch (e) {\n          _this.callback(e);\n        }\n      });\n    });\n  }\n\n  WSDL.prototype.onReady = function (callback) {\n    if (callback) {\n      this.callback = callback;\n    }\n  };\n\n  WSDL.prototype.processIncludes = function (callback) {\n    var schemas = this.definitions.schemas;\n    var includes = [];\n\n    for (var ns in schemas) {\n      var schema = schemas[ns];\n      includes = includes.concat(schema.includes || []);\n    }\n\n    this._processNextInclude(includes, callback);\n  };\n\n  WSDL.prototype.describeServices = function () {\n    var services = {};\n\n    for (var name_1 in this.services) {\n      var service = this.services[name_1];\n      services[name_1] = service.description(this.definitions);\n    }\n\n    return services;\n  };\n\n  WSDL.prototype.toXML = function () {\n    return this.xml || '';\n  };\n\n  WSDL.prototype.getSaxStream = function (xml) {\n    var saxStream = sax.createStream(true, null);\n    xml.pipe(saxStream);\n    return saxStream;\n  };\n\n  WSDL.prototype.xmlToObject = function (xml, callback) {\n    var _this = this;\n\n    var p = typeof callback === 'function' ? {} : sax.parser(true, null);\n    var objectName = null;\n    var root = {};\n    var schema = {\n      Envelope: {\n        Header: {\n          Security: {\n            UsernameToken: {\n              Username: 'string',\n              Password: 'string'\n            }\n          }\n        },\n        Body: {\n          Fault: {\n            faultcode: 'string',\n            faultstring: 'string',\n            detail: 'string'\n          }\n        }\n      }\n    };\n    var stack = [{\n      name: null,\n      object: root,\n      schema: schema\n    }];\n    var xmlns = {};\n    var refs = {};\n    var id; // {id:{hrefs:[],obj:}, ...}\n\n    p.onopentag = function (node) {\n      var nsName = node.name;\n      var attrs = node.attributes;\n      var name = utils_1.splitQName(nsName).name;\n      var attributeName;\n      var top = stack[stack.length - 1];\n      var topSchema = top.schema;\n      var elementAttributes = {};\n      var hasNonXmlnsAttribute = false;\n      var hasNilAttribute = false;\n      var obj = {};\n      var originalName = name;\n\n      if (!objectName && top.name === 'Body' && name !== 'Fault') {\n        var message = _this.definitions.messages[name]; // Support RPC/literal messages where response body contains one element named\n        // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names\n\n        if (!message) {\n          try {\n            // Determine if this is request or response\n            var isInput = false;\n            var isOutput = false;\n\n            if (/Response$/.test(name)) {\n              isOutput = true;\n              name = name.replace(/Response$/, '');\n            } else if (/Request$/.test(name)) {\n              isInput = true;\n              name = name.replace(/Request$/, '');\n            } else if (/Solicit$/.test(name)) {\n              isInput = true;\n              name = name.replace(/Solicit$/, '');\n            } // Look up the appropriate message as given in the portType's operations\n\n\n            var portTypes = _this.definitions.portTypes;\n            var portTypeNames = Object.keys(portTypes); // Currently this supports only one portType definition.\n\n            var portType = portTypes[portTypeNames[0]];\n\n            if (isInput) {\n              name = portType.methods[name].input.$name;\n            } else {\n              name = portType.methods[name].output.$name;\n            }\n\n            message = _this.definitions.messages[name]; // 'cache' this alias to speed future lookups\n\n            _this.definitions.messages[originalName] = _this.definitions.messages[name];\n          } catch (e) {\n            if (_this.options.returnFault) {\n              p.onerror(e);\n            }\n          }\n        }\n\n        topSchema = message.description(_this.definitions);\n        objectName = originalName;\n      }\n\n      if (attrs.href) {\n        id = attrs.href.substr(1);\n\n        if (!refs[id]) {\n          refs[id] = {\n            hrefs: [],\n            obj: null\n          };\n        }\n\n        refs[id].hrefs.push({\n          par: top.object,\n          key: name,\n          obj: obj\n        });\n      }\n\n      if (id = attrs.id) {\n        if (!refs[id]) {\n          refs[id] = {\n            hrefs: [],\n            obj: null\n          };\n        }\n      } // Handle element attributes\n\n\n      for (attributeName in attrs) {\n        if (/^xmlns:|^xmlns$/.test(attributeName)) {\n          xmlns[utils_1.splitQName(attributeName).name] = attrs[attributeName];\n          continue;\n        }\n\n        hasNonXmlnsAttribute = true;\n        elementAttributes[attributeName] = attrs[attributeName];\n      }\n\n      for (attributeName in elementAttributes) {\n        var res = utils_1.splitQName(attributeName);\n\n        if (res.name === 'nil' && xmlns[res.prefix] === XSI_URI && elementAttributes[attributeName] && (elementAttributes[attributeName].toLowerCase() === 'true' || elementAttributes[attributeName] === '1')) {\n          hasNilAttribute = true;\n          break;\n        }\n      }\n\n      if (hasNonXmlnsAttribute) {\n        obj[_this.options.attributesKey] = elementAttributes;\n      } // Pick up the schema for the type specified in element's xsi:type attribute.\n\n\n      var xsiTypeSchema;\n      var xsiType;\n\n      for (var prefix in xmlns) {\n        if (xmlns[prefix] === XSI_URI && prefix + \":type\" in elementAttributes) {\n          xsiType = elementAttributes[prefix + \":type\"];\n          break;\n        }\n      }\n\n      if (xsiType) {\n        var type = utils_1.splitQName(xsiType);\n        var typeURI = void 0;\n\n        if (type.prefix === utils_1.TNS_PREFIX) {\n          // In case of xsi:type = \"MyType\"\n          typeURI = xmlns[type.prefix] || xmlns.xmlns;\n        } else {\n          typeURI = xmlns[type.prefix];\n        }\n\n        var typeDef = _this.findSchemaObject(typeURI, type.name);\n\n        if (typeDef) {\n          xsiTypeSchema = typeDef.description(_this.definitions);\n        }\n      }\n\n      if (topSchema && topSchema[name + '[]']) {\n        name = name + '[]';\n      }\n\n      stack.push({\n        name: originalName,\n        object: obj,\n        schema: xsiTypeSchema || topSchema && topSchema[name],\n        id: attrs.id,\n        nil: hasNilAttribute\n      });\n    };\n\n    p.onclosetag = function (nsName) {\n      var cur = stack.pop();\n      var obj = cur.object;\n      var top = stack[stack.length - 1];\n      var topObject = top.object;\n      var topSchema = top.schema;\n      var name = utils_1.splitQName(nsName).name;\n\n      if (typeof cur.schema === 'string' && (cur.schema === 'string' || cur.schema.split(':')[1] === 'string')) {\n        if (typeof obj === 'object' && Object.keys(obj).length === 0) {\n          obj = cur.object = '';\n        }\n      }\n\n      if (cur.nil === true) {\n        if (_this.options.handleNilAsNull) {\n          obj = null;\n        } else {\n          return;\n        }\n      }\n\n      if (_.isPlainObject(obj) && !Object.keys(obj).length) {\n        obj = null;\n      }\n\n      if (topSchema && topSchema[name + '[]']) {\n        if (!topObject[name]) {\n          topObject[name] = [];\n        }\n\n        topObject[name].push(obj);\n      } else if (name in topObject) {\n        if (!Array.isArray(topObject[name])) {\n          topObject[name] = [topObject[name]];\n        }\n\n        topObject[name].push(obj);\n      } else {\n        topObject[name] = obj;\n      }\n\n      if (cur.id) {\n        refs[cur.id].obj = obj;\n      }\n    };\n\n    p.oncdata = function (text) {\n      var originalText = text;\n      text = trim(text);\n\n      if (!text.length) {\n        return;\n      }\n\n      if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\n        var top_1 = stack[stack.length - 1];\n\n        var value = _this.xmlToObject(text);\n\n        if (top_1.object[_this.options.attributesKey]) {\n          top_1.object[_this.options.valueKey] = value;\n        } else {\n          top_1.object = value;\n        }\n      } else {\n        p.ontext(originalText);\n      }\n    };\n\n    p.onerror = function (e) {\n      p.resume();\n      throw {\n        Fault: {\n          faultcode: 500,\n          faultstring: 'Invalid XML',\n          detail: new Error(e).message,\n          statusCode: 500\n        }\n      };\n    };\n\n    p.ontext = function (text) {\n      var originalText = text;\n      text = trim(text);\n\n      if (!text.length) {\n        return;\n      }\n\n      var top = stack[stack.length - 1];\n      var name = utils_1.splitQName(top.schema).name;\n      var value;\n\n      if (_this.options && _this.options.customDeserializer && _this.options.customDeserializer[name]) {\n        value = _this.options.customDeserializer[name](text, top);\n      } else {\n        if (name === 'int' || name === 'integer' || name === 'short' || name === 'long') {\n          value = parseInt(text, 10);\n        } else if (name === 'double' || name === 'float' || name === 'decimal') {\n          value = Number(text);\n        } else if (name === 'bool' || name === 'boolean') {\n          value = text.toLowerCase() === 'true' || text === '1';\n        } else if (name === 'dateTime' || name === 'date') {\n          value = new Date(text);\n        } else {\n          if (_this.options.preserveWhitespace) {\n            text = originalText;\n          } // handle string or other types\n\n\n          if (typeof top.object !== 'string') {\n            value = text;\n          } else {\n            value = top.object + text;\n          }\n        }\n      }\n\n      if (top.object[_this.options.attributesKey]) {\n        top.object[_this.options.valueKey] = value;\n      } else {\n        top.object = value;\n      }\n    };\n\n    if (typeof callback === 'function') {\n      // we be streaming\n      var saxStream = sax.createStream(true, null);\n      saxStream.on('opentag', p.onopentag);\n      saxStream.on('closetag', p.onclosetag);\n      saxStream.on('cdata', p.oncdata);\n      saxStream.on('text', p.ontext);\n      xml.pipe(saxStream).on('error', function (err) {\n        callback(err);\n      }).on('end', function () {\n        var r;\n\n        try {\n          r = finish();\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null, r);\n      });\n      return;\n    }\n\n    p.write(xml).close();\n    return finish();\n\n    function finish() {\n      // MultiRef support: merge objects instead of replacing\n      for (var n in refs) {\n        var ref = refs[n];\n\n        for (var _i = 0, _a = ref.hrefs; _i < _a.length; _i++) {\n          var href = _a[_i];\n          Object.assign(href.obj, ref.obj);\n        }\n      }\n\n      if (root.Envelope) {\n        var body = root.Envelope.Body;\n\n        if (body && body.Fault) {\n          var code = body.Fault.faultcode && body.Fault.faultcode.$value;\n          var string = body.Fault.faultstring && body.Fault.faultstring.$value;\n          var detail = body.Fault.detail && body.Fault.detail.$value;\n          code = code || body.Fault.faultcode;\n          string = string || body.Fault.faultstring;\n          detail = detail || body.Fault.detail;\n          var error = new Error(code + ': ' + string + (detail ? ': ' + JSON.stringify(detail) : ''));\n          error.root = root;\n          throw error;\n        }\n\n        return root.Envelope;\n      }\n\n      return root;\n    }\n  };\n  /**\n   * Look up a XSD type or element by namespace URI and name\n   * @param {String} nsURI Namespace URI\n   * @param {String} qname Local or qualified name\n   * @returns {*} The XSD type/element definition\n   */\n\n\n  WSDL.prototype.findSchemaObject = function (nsURI, qname) {\n    if (!nsURI || !qname) {\n      return null;\n    }\n\n    var def = null;\n\n    if (this.definitions.schemas) {\n      var schema = this.definitions.schemas[nsURI];\n\n      if (schema) {\n        if (qname.indexOf(':') !== -1) {\n          qname = qname.substring(qname.indexOf(':') + 1, qname.length);\n        } // if the client passed an input element which has a `$lookupType` property instead of `$type`\n        // the `def` is found in `schema.elements`.\n\n\n        def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];\n      }\n    }\n\n    return def;\n  };\n  /**\n   * Create document style xml string from the parameters\n   * @param {String} name\n   * @param {*} params\n   * @param {String} nsPrefix\n   * @param {String} nsURI\n   * @param {String} type\n   */\n\n\n  WSDL.prototype.objectToDocumentXML = function (name, params, nsPrefix, nsURI, type) {\n    // If user supplies XML already, just use that.  XML Declaration should not be present.\n    if (params && params._xml) {\n      return params._xml;\n    }\n\n    var args = {};\n    args[name] = params;\n    var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;\n    return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);\n  };\n  /**\n   * Create RPC style xml string from the parameters\n   * @param {String} name\n   * @param {*} params\n   * @param {String} nsPrefix\n   * @param {String} nsURI\n   * @returns {string}\n   */\n\n\n  WSDL.prototype.objectToRpcXML = function (name, params, nsPrefix, nsURI, isParts) {\n    var parts = [];\n    var defs = this.definitions;\n    var nsAttrName = '_xmlns';\n    nsPrefix = nsPrefix || utils_1.findPrefix(defs.xmlns, nsURI);\n    nsURI = nsURI || defs.xmlns[nsPrefix];\n    nsPrefix = nsPrefix === utils_1.TNS_PREFIX ? '' : nsPrefix + ':';\n    parts.push(['<', nsPrefix, name, '>'].join(''));\n\n    for (var key in params) {\n      if (!params.hasOwnProperty(key)) {\n        continue;\n      }\n\n      if (key !== nsAttrName) {\n        var value = params[key];\n        var prefixedKey = (isParts ? '' : nsPrefix) + key;\n        var attributes = [];\n\n        if (typeof value === 'object' && value.hasOwnProperty(this.options.attributesKey)) {\n          var attrs = value[this.options.attributesKey];\n\n          for (var n in attrs) {\n            attributes.push(' ' + n + '=' + '\"' + attrs[n] + '\"');\n          }\n        }\n\n        parts.push(['<', prefixedKey].concat(attributes).concat('>').join(''));\n        parts.push(typeof value === 'object' ? this.objectToXML(value, key, nsPrefix, nsURI) : utils_1.xmlEscape(value));\n        parts.push(['</', prefixedKey, '>'].join(''));\n      }\n    }\n\n    parts.push(['</', nsPrefix, name, '>'].join(''));\n    return parts.join('');\n  };\n\n  WSDL.prototype.isIgnoredNameSpace = function (ns) {\n    return this.options.ignoredNamespaces.indexOf(ns) > -1;\n  };\n\n  WSDL.prototype.filterOutIgnoredNameSpace = function (ns) {\n    var namespace = noColonNameSpace(ns);\n    return this.isIgnoredNameSpace(namespace) ? '' : namespace;\n  };\n  /**\n   * Convert an object to XML.  This is a recursive method as it calls itself.\n   *\n   * @param {Object} obj the object to convert.\n   * @param {String} name the name of the element (if the object being traversed is\n   * an element).\n   * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.\n   * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.\n   * @param {Boolean} isFirst whether or not this is the first item being traversed.\n   * @param {?} xmlnsAttr\n   * @param {?} parameterTypeObject\n   * @param {NamespaceContext} nsContext Namespace context\n   */\n\n\n  WSDL.prototype.objectToXML = function (obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {\n    var schema = this.definitions.schemas[nsURI];\n    var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;\n\n    if (typeof parentNsPrefix !== 'undefined') {\n      // we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string\n      nsPrefix = nsPrefix.current;\n    }\n\n    parentNsPrefix = noColonNameSpace(parentNsPrefix);\n\n    if (this.isIgnoredNameSpace(parentNsPrefix)) {\n      parentNsPrefix = '';\n    }\n\n    var soapHeader = !schema;\n    var qualified = schema && schema.$elementFormDefault === 'qualified';\n    var parts = [];\n    var prefixNamespace = (nsPrefix || qualified) && nsPrefix !== utils_1.TNS_PREFIX;\n    var xmlnsAttrib = '';\n\n    if (nsURI && isFirst) {\n      if (this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes) {\n        this.options.overrideRootElement.xmlnsAttributes.forEach(function (attribute) {\n          xmlnsAttrib += ' ' + attribute.name + '=\"' + attribute.value + '\"';\n        });\n      } else {\n        if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {\n          // resolve the prefix namespace\n          xmlnsAttrib += ' xmlns:' + nsPrefix + '=\"' + nsURI + '\"';\n        } // only add default namespace if the schema elementFormDefault is qualified\n\n\n        if (qualified || soapHeader) {\n          xmlnsAttrib += ' xmlns=\"' + nsURI + '\"';\n        }\n      }\n    }\n\n    if (!nsContext) {\n      nsContext = new nscontext_1.NamespaceContext();\n      nsContext.declareNamespace(nsPrefix, nsURI);\n    } else {\n      nsContext.pushContext();\n    } // explicitly use xmlns attribute if available\n\n\n    if (xmlnsAttr && !(this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes)) {\n      xmlnsAttrib = xmlnsAttr;\n    }\n\n    var ns = '';\n\n    if (this.options.overrideRootElement && isFirst) {\n      ns = this.options.overrideRootElement.namespace;\n    } else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {\n      ns = nsPrefix;\n    }\n\n    var i;\n    var n; // start building out XML string.\n\n    if (Array.isArray(obj)) {\n      var nonSubNameSpace = '';\n      var emptyNonSubNameSpaceForArray = false;\n      var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n\n      if (nameWithNsRegex) {\n        nonSubNameSpace = nameWithNsRegex[1];\n        name = nameWithNsRegex[2];\n      } else if (name[0] === ':') {\n        emptyNonSubNameSpaceForArray = true;\n        name = name.substr(1);\n      }\n\n      for (i = 0, n = obj.length; i < n; i++) {\n        var item = obj[i];\n        var arrayAttr = this.processAttributes(item, nsContext);\n        var correctOuterNsPrefix = nonSubNameSpace || parentNsPrefix || ns; // using the parent namespace prefix if given\n\n        var body = this.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n        var openingTagParts = ['<', name, arrayAttr, xmlnsAttrib];\n\n        if (!emptyNonSubNameSpaceForArray) {\n          openingTagParts = ['<', appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib];\n        }\n\n        if (body === '' && this.options.useEmptyTag) {\n          // Use empty (self-closing) tags if no contents\n          openingTagParts.push(' />');\n          parts.push(openingTagParts.join(''));\n        } else {\n          openingTagParts.push('>');\n\n          if (this.options.namespaceArrayElements || i === 0) {\n            parts.push(openingTagParts.join(''));\n          }\n\n          parts.push(body);\n\n          if (this.options.namespaceArrayElements || i === n - 1) {\n            if (emptyNonSubNameSpaceForArray) {\n              parts.push(['</', name, '>'].join(''));\n            } else {\n              parts.push(['</', appendColon(correctOuterNsPrefix), name, '>'].join(''));\n            }\n          }\n        }\n      }\n    } else if (typeof obj === 'object') {\n      var currentChildXmlnsAttrib = '';\n\n      for (name in obj) {\n        // Happens when Object.create(null) is used, it will not inherit the Object prototype\n        if (!obj.hasOwnProperty) {\n          obj = Object.assign({}, obj);\n        }\n\n        if (!obj.hasOwnProperty(name)) {\n          continue;\n        } // don't process attributes as element\n\n\n        if (name === this.options.attributesKey) {\n          continue;\n        } // Its the value of a xml object. Return it directly.\n\n\n        if (name === this.options.xmlKey) {\n          nsContext.popContext();\n          return obj[name];\n        } // Its the value of an item. Return it directly.\n\n\n        if (name === this.options.valueKey) {\n          nsContext.popContext();\n          return utils_1.xmlEscape(obj[name]);\n        }\n\n        var child = obj[name];\n\n        if (typeof child === 'undefined') {\n          continue;\n        }\n\n        var attr = this.processAttributes(child, nsContext);\n        var value = '';\n        var nonSubNameSpace = '';\n        var emptyNonSubNameSpace = false;\n        var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n\n        if (nameWithNsRegex) {\n          nonSubNameSpace = nameWithNsRegex[1] + ':';\n          name = nameWithNsRegex[2];\n        } else if (name[0] === ':') {\n          emptyNonSubNameSpace = true;\n          name = name.substr(1);\n        }\n\n        if (isFirst) {\n          value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n        } else {\n          if (this.definitions.schemas) {\n            if (schema) {\n              var childSchemaObject = this.findChildSchemaObject(schemaObject, name); // find sub namespace if not a primitive\n\n              if (childSchemaObject && (childSchemaObject.$type && childSchemaObject.$type.indexOf('xsd:') === -1 || childSchemaObject.$ref || childSchemaObject.$name)) {\n                /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.\n                 This is because in some services the child nodes do not need the baseNameSpace.\n                 */\n                var childNsPrefix = '';\n                var childName = '';\n                var childNsURI = void 0;\n                var childXmlnsAttrib = '';\n                var elementQName = childSchemaObject.$ref || childSchemaObject.$name;\n\n                if (elementQName) {\n                  elementQName = utils_1.splitQName(elementQName);\n                  childName = elementQName.name;\n\n                  if (elementQName.prefix === utils_1.TNS_PREFIX) {\n                    // Local element\n                    childNsURI = childSchemaObject.$targetNamespace;\n                    childNsPrefix = nsContext.registerNamespace(childNsURI);\n\n                    if (this.isIgnoredNameSpace(childNsPrefix)) {\n                      childNsPrefix = nsPrefix;\n                    }\n                  } else {\n                    childNsPrefix = elementQName.prefix;\n\n                    if (this.isIgnoredNameSpace(childNsPrefix)) {\n                      childNsPrefix = nsPrefix;\n                    }\n\n                    childNsURI = schema.xmlns[childNsPrefix] || this.definitions.xmlns[childNsPrefix];\n                  }\n\n                  var unqualified = false; // Check qualification form for local elements\n\n                  if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {\n                    if (childSchemaObject.$form === 'unqualified') {\n                      unqualified = true;\n                    } else if (childSchemaObject.$form === 'qualified') {\n                      unqualified = false;\n                    } else {\n                      unqualified = schema.$elementFormDefault !== 'qualified';\n                    }\n                  }\n\n                  if (unqualified) {\n                    childNsPrefix = '';\n                  }\n\n                  if (childNsURI && childNsPrefix) {\n                    if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {\n                      childXmlnsAttrib = ' xmlns:' + childNsPrefix + '=\"' + childNsURI + '\"';\n\n                      if (!xmlnsAttrib.includes(childNsPrefix)) {\n                        currentChildXmlnsAttrib = childXmlnsAttrib;\n                        xmlnsAttrib += childXmlnsAttrib;\n                      }\n                    }\n                  }\n                }\n\n                var resolvedChildSchemaObject = void 0;\n\n                if (childSchemaObject.$type) {\n                  var typeQName = utils_1.splitQName(childSchemaObject.$type);\n                  var typePrefix = typeQName.prefix;\n                  var typeURI = schema.xmlns[typePrefix] || this.definitions.xmlns[typePrefix];\n                  childNsURI = typeURI;\n\n                  if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== utils_1.TNS_PREFIX) {\n                    // Add the prefix/namespace mapping, but not declare it\n                    nsContext.addNamespace(typePrefix, typeURI);\n                  }\n\n                  resolvedChildSchemaObject = this.findSchemaType(typeQName.name, typeURI) || childSchemaObject;\n                } else {\n                  resolvedChildSchemaObject = this.findSchemaObject(childNsURI, childName) || childSchemaObject;\n                }\n\n                if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {\n                  childNsPrefix = nsPrefix;\n                  childNsURI = nsURI;\n                }\n\n                if (this.options.ignoreBaseNameSpaces) {\n                  childNsPrefix = '';\n                  childNsURI = '';\n                }\n\n                ns = childNsPrefix;\n\n                if (Array.isArray(child)) {\n                  // for arrays, we need to remember the current namespace\n                  childNsPrefix = {\n                    current: childNsPrefix,\n                    parent: ns\n                  };\n                  childXmlnsAttrib = childXmlnsAttrib && childXmlnsAttrib.length ? childXmlnsAttrib : currentChildXmlnsAttrib;\n                } else {\n                  // parent (array) already got the namespace\n                  childXmlnsAttrib = null;\n                }\n\n                value = this.objectToXML(child, name, childNsPrefix, childNsURI, false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);\n              } else if (obj[this.options.attributesKey] && obj[this.options.attributesKey].xsi_type) {\n                // if parent object has complex type defined and child not found in parent\n                var completeChildParamTypeObject = this.findChildSchemaObject(obj[this.options.attributesKey].xsi_type.type, obj[this.options.attributesKey].xsi_type.xmlns);\n                nonSubNameSpace = obj[this.options.attributesKey].xsi_type.prefix;\n                nsContext.addNamespace(obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns);\n                value = this.objectToXML(child, name, obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);\n              } else {\n                if (Array.isArray(child)) {\n                  if (emptyNonSubNameSpace) {\n                    name = ':' + name;\n                  } else {\n                    name = nonSubNameSpace + name;\n                  }\n                }\n\n                value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n              }\n            } else {\n              value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n            }\n          }\n        }\n\n        ns = noColonNameSpace(ns);\n\n        if (prefixNamespace && !qualified && isFirst && !this.options.overrideRootElement) {\n          ns = nsPrefix;\n        } else if (this.isIgnoredNameSpace(ns)) {\n          ns = '';\n        }\n\n        var useEmptyTag = !value && this.options.useEmptyTag;\n\n        if (!Array.isArray(child)) {\n          // start tag\n          parts.push(['<', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, attr, xmlnsAttrib, child === null ? ' xsi:nil=\"true\"' : '', useEmptyTag ? ' />' : '>'].join(''));\n        }\n\n        if (!useEmptyTag) {\n          parts.push(value);\n\n          if (!Array.isArray(child)) {\n            // end tag\n            parts.push(['</', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, '>'].join(''));\n          }\n        }\n      }\n    } else if (obj !== undefined) {\n      parts.push(this.options.escapeXML ? utils_1.xmlEscape(obj) : obj);\n    }\n\n    nsContext.popContext();\n    return parts.join('');\n  };\n\n  WSDL.prototype.processAttributes = function (child, nsContext) {\n    var attr = '';\n\n    if (child === null || child === undefined) {\n      child = [];\n    }\n\n    var attrObj = child[this.options.attributesKey] || {};\n\n    if (attrObj && attrObj.xsi_type) {\n      var xsiType = attrObj.xsi_type;\n      var prefix = xsiType.prefix || xsiType.namespace;\n\n      if (xsiType.xmlns) {\n        // Generate a new namespace for complex extension if one not provided\n        if (!prefix) {\n          prefix = nsContext.registerNamespace(xsiType.xmlns);\n        } else {\n          nsContext.declareNamespace(prefix, xsiType.xmlns);\n        }\n\n        xsiType.prefix = prefix;\n      }\n    }\n\n    Object.keys(attrObj).forEach(function (k) {\n      var v = attrObj[k];\n\n      if (k === 'xsi_type') {\n        var name_2 = v.type;\n\n        if (v.prefix) {\n          name_2 = v.prefix + \":\" + name_2;\n        }\n\n        attr += \" xsi:type=\\\"\" + name_2 + \"\\\"\";\n\n        if (v.xmlns) {\n          attr += \" xmlns:\" + v.prefix + \"=\\\"\" + v.xmlns + \"\\\"\";\n        }\n      } else {\n        attr += \" \" + k + \"=\\\"\" + utils_1.xmlEscape(v) + \"\\\"\";\n      }\n    });\n    return attr;\n  };\n  /**\n   * Look up a schema type definition\n   * @param name\n   * @param nsURI\n   * @returns {*}\n   */\n\n\n  WSDL.prototype.findSchemaType = function (name, nsURI) {\n    if (!this.definitions.schemas || !name || !nsURI) {\n      return null;\n    }\n\n    var schema = this.definitions.schemas[nsURI];\n\n    if (!schema || !schema.complexTypes) {\n      return null;\n    }\n\n    return schema.complexTypes[name];\n  };\n\n  WSDL.prototype.findChildSchemaObject = function (parameterTypeObj, childName, backtrace) {\n    if (!parameterTypeObj || !childName) {\n      return null;\n    }\n\n    if (!backtrace) {\n      backtrace = [];\n    }\n\n    if (backtrace.indexOf(parameterTypeObj) >= 0) {\n      // We've recursed back to ourselves; break.\n      return null;\n    } else {\n      backtrace = backtrace.concat([parameterTypeObj]);\n    }\n\n    var found = null;\n    var i = 0;\n    var child;\n    var ref;\n\n    if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {\n      var types = parameterTypeObj.$lookupTypes;\n\n      for (i = 0; i < types.length; i++) {\n        var typeObj = types[i];\n\n        if (typeObj.$name === childName) {\n          found = typeObj;\n          break;\n        }\n      }\n    }\n\n    var object = parameterTypeObj;\n\n    if (object.$name === childName && object.name === 'element') {\n      return object;\n    }\n\n    if (object.$ref) {\n      ref = utils_1.splitQName(object.$ref);\n\n      if (ref.name === childName) {\n        return object;\n      }\n    }\n\n    var childNsURI; // want to avoid unecessary recursion to improve performance\n\n    if (object.$type && backtrace.length === 1) {\n      var typeInfo = utils_1.splitQName(object.$type);\n\n      if (typeInfo.prefix === utils_1.TNS_PREFIX) {\n        childNsURI = parameterTypeObj.$targetNamespace;\n      } else {\n        childNsURI = this.definitions.xmlns[typeInfo.prefix];\n      }\n\n      var typeDef = this.findSchemaType(typeInfo.name, childNsURI);\n\n      if (typeDef) {\n        return this.findChildSchemaObject(typeDef, childName, backtrace);\n      }\n    } // handle $base (e.g. for ExtensionElement) like $type\n\n\n    if (object.$base && (!Array.isArray(object.children) || !object.children.length)) {\n      var baseInfo = utils_1.splitQName(object.$base);\n      childNsURI = parameterTypeObj.$targetNamespace;\n\n      if (baseInfo.prefix !== utils_1.TNS_PREFIX) {\n        childNsURI = this.definitions.xmlns[baseInfo.prefix];\n      }\n\n      var baseDef = this.findSchemaType(baseInfo.name, childNsURI);\n\n      if (baseDef) {\n        return this.findChildSchemaObject(baseDef, childName, backtrace);\n      }\n    }\n\n    if (Array.isArray(object.children) && object.children.length > 0) {\n      for (i = 0, child; child = object.children[i]; i++) {\n        found = this.findChildSchemaObject(child, childName, backtrace);\n\n        if (found) {\n          break;\n        }\n\n        if (child.$base) {\n          var baseQName = utils_1.splitQName(child.$base);\n          var childNameSpace = baseQName.prefix === utils_1.TNS_PREFIX ? '' : baseQName.prefix;\n          childNsURI = child.xmlns[baseQName.prefix] || child.schemaXmlns[baseQName.prefix];\n          var foundBase = this.findSchemaType(baseQName.name, childNsURI);\n\n          if (foundBase) {\n            found = this.findChildSchemaObject(foundBase, childName, backtrace);\n\n            if (found) {\n              found.$baseNameSpace = childNameSpace;\n              found.$type = childNameSpace + ':' + childName;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (!found && object.$name === childName) {\n      return object;\n    }\n\n    return found;\n  };\n\n  WSDL.prototype._initializeOptions = function (options) {\n    this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;\n    this.options = {};\n    var ignoredNamespaces = options ? options.ignoredNamespaces : null;\n\n    if (ignoredNamespaces && (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {\n      if (ignoredNamespaces.override) {\n        this.options.ignoredNamespaces = ignoredNamespaces.namespaces;\n      } else {\n        this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);\n      }\n    } else {\n      this.options.ignoredNamespaces = this.ignoredNamespaces;\n    }\n\n    this.options.valueKey = options.valueKey || this.valueKey;\n    this.options.xmlKey = options.xmlKey || this.xmlKey;\n\n    if (options.escapeXML !== undefined) {\n      this.options.escapeXML = options.escapeXML;\n    } else {\n      this.options.escapeXML = true;\n    }\n\n    if (options.returnFault !== undefined) {\n      this.options.returnFault = options.returnFault;\n    } else {\n      this.options.returnFault = false;\n    }\n\n    this.options.handleNilAsNull = !!options.handleNilAsNull;\n\n    if (options.namespaceArrayElements !== undefined) {\n      this.options.namespaceArrayElements = options.namespaceArrayElements;\n    } else {\n      this.options.namespaceArrayElements = true;\n    } // Allow any request headers to keep passing through\n\n\n    this.options.wsdl_headers = options.wsdl_headers;\n    this.options.wsdl_options = options.wsdl_options;\n\n    if (options.httpClient) {\n      this.options.httpClient = options.httpClient;\n    } // The supplied request-object should be passed through\n\n\n    if (options.request) {\n      this.options.request = options.request;\n    }\n\n    var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;\n\n    if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {\n      this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;\n    } else {\n      this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;\n    } // Works only in client\n\n\n    this.options.forceSoap12Headers = options.forceSoap12Headers;\n    this.options.customDeserializer = options.customDeserializer;\n\n    if (options.overrideRootElement !== undefined) {\n      this.options.overrideRootElement = options.overrideRootElement;\n    }\n\n    this.options.useEmptyTag = !!options.useEmptyTag;\n  };\n\n  WSDL.prototype._processNextInclude = function (includes, callback) {\n    var _this = this;\n\n    var include = includes.shift();\n\n    if (!include) {\n      return callback();\n    }\n\n    var includePath;\n\n    if (!/^https?:/i.test(this.uri) && !/^https?:/i.test(include.location)) {\n      var isFixed = this.options.wsdl_options !== undefined && this.options.wsdl_options.hasOwnProperty('fixedPath') ? this.options.wsdl_options.fixedPath : false;\n\n      if (isFixed) {\n        includePath = path.resolve(path.dirname(this.uri), path.parse(include.location).base);\n      } else {\n        includePath = path.resolve(path.dirname(this.uri), include.location);\n      }\n    } else {\n      includePath = url.resolve(this.uri || '', include.location);\n    }\n\n    if (this.options.wsdl_options !== undefined && typeof this.options.wsdl_options.overrideImportLocation === 'function') {\n      includePath = this.options.wsdl_options.overrideImportLocation(includePath);\n    }\n\n    var options = Object.assign({}, this.options); // follow supplied ignoredNamespaces option\n\n    options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;\n    options.WSDL_CACHE = this.WSDL_CACHE;\n    open_wsdl_recursive(includePath, options, function (err, wsdl) {\n      if (err) {\n        return callback(err);\n      }\n\n      _this._includesWsdl.push(wsdl);\n\n      if (wsdl.definitions instanceof elements.DefinitionsElement) {\n        _.mergeWith(_this.definitions, wsdl.definitions, function (a, b) {\n          return a instanceof elements.SchemaElement ? a.merge(b) : undefined;\n        });\n      } else {\n        return callback(new Error('wsdl.defintions is not an instance of elements.DefinitionsElement'));\n      }\n\n      _this._processNextInclude(includes, function (err) {\n        callback(err);\n      });\n    });\n  };\n\n  WSDL.prototype._parse = function (xml) {\n    var _this = this;\n\n    var p = sax.parser(true, null);\n    var stack = [];\n    var root = null;\n    var types = null;\n    var schema = null;\n    var schemaAttrs = null;\n    var options = this.options;\n\n    p.onopentag = function (node) {\n      var nsName = node.name;\n      var attrs = node.attributes;\n      var top = stack[stack.length - 1];\n      var name = utils_1.splitQName(nsName).name;\n\n      if (name === 'schema') {\n        schemaAttrs = attrs;\n      }\n\n      if (top) {\n        try {\n          top.startElement(stack, nsName, attrs, options, schemaAttrs);\n        } catch (e) {\n          if (_this.options.strict) {\n            throw e;\n          } else {\n            stack.push(new elements.Element(nsName, attrs, options, schemaAttrs));\n          }\n        }\n      } else {\n        if (name === 'definitions') {\n          root = new elements.DefinitionsElement(nsName, attrs, options);\n          stack.push(root);\n        } else if (name === 'schema') {\n          // Shim a structure in here to allow the proper objects to be created when merging back.\n          root = new elements.DefinitionsElement('definitions', {}, {});\n          types = new elements.TypesElement('types', {}, {});\n          schema = new elements.SchemaElement(nsName, attrs, options);\n          types.addChild(schema);\n          root.addChild(types);\n          stack.push(schema);\n        } else {\n          throw new Error('Unexpected root element of WSDL or include');\n        }\n      }\n    };\n\n    p.onclosetag = function (name) {\n      var top = stack[stack.length - 1];\n      assert_1.ok(top, 'Unmatched close tag: ' + name);\n      top.endElement(stack, name);\n    };\n\n    p.write(xml).close();\n    return root;\n  };\n\n  WSDL.prototype._fromXML = function (xml) {\n    this.definitions = this._parse(xml);\n    this.definitions.descriptions = {\n      types: {},\n      elements: {}\n    };\n    this.xml = xml;\n  };\n\n  WSDL.prototype._fromServices = function (services) {};\n\n  WSDL.prototype._xmlnsMap = function () {\n    var xmlns = this.definitions.xmlns;\n    var str = '';\n\n    for (var alias in xmlns) {\n      if (alias === '' || alias === utils_1.TNS_PREFIX) {\n        continue;\n      }\n\n      var ns = xmlns[alias];\n\n      switch (ns) {\n        case 'http://xml.apache.org/xml-soap': // apachesoap\n\n        case 'http://schemas.xmlsoap.org/wsdl/': // wsdl\n\n        case 'http://schemas.xmlsoap.org/wsdl/soap/': // wsdlsoap\n\n        case 'http://schemas.xmlsoap.org/wsdl/soap12/': // wsdlsoap12\n\n        case 'http://schemas.xmlsoap.org/soap/encoding/': // soapenc\n\n        case 'http://www.w3.org/2001/XMLSchema':\n          // xsd\n          continue;\n      }\n\n      if (~ns.indexOf('http://schemas.xmlsoap.org/')) {\n        continue;\n      }\n\n      if (~ns.indexOf('http://www.w3.org/')) {\n        continue;\n      }\n\n      if (~ns.indexOf('http://xml.apache.org/')) {\n        continue;\n      }\n\n      str += ' xmlns:' + alias + '=\"' + ns + '\"';\n    }\n\n    return str;\n  };\n\n  return WSDL;\n}();\n\nexports.WSDL = WSDL;\n\nfunction open_wsdl_recursive(uri, p2, p3) {\n  var fromCache;\n  var WSDL_CACHE;\n  var options;\n  var callback;\n\n  if (typeof p2 === 'function') {\n    options = {};\n    callback = p2;\n  } else {\n    options = p2;\n    callback = p3;\n  }\n\n  WSDL_CACHE = options.WSDL_CACHE;\n\n  if (fromCache = WSDL_CACHE[uri]) {\n    return callback.call(fromCache, null, fromCache);\n  }\n\n  return open_wsdl(uri, options, callback);\n}\n\nfunction open_wsdl(uri, p2, p3) {\n  var options;\n  var callback;\n\n  if (typeof p2 === 'function') {\n    options = {};\n    callback = p2;\n  } else if (typeof p3 === 'function') {\n    options = p2;\n    callback = p3;\n  } // initialize cache when calling open_wsdl directly\n\n\n  var WSDL_CACHE = options.WSDL_CACHE || {};\n  var request_headers = options.wsdl_headers;\n  var request_options = options.wsdl_options;\n  var wsdl;\n\n  if (!/^https?:/i.test(uri)) {\n    debug('Reading file: %s', uri);\n    fs.readFile(uri, 'utf8', function (err, definition) {\n      if (err) {\n        callback(err);\n      } else {\n        wsdl = new WSDL(definition, uri, options);\n        WSDL_CACHE[uri] = wsdl;\n        wsdl.WSDL_CACHE = WSDL_CACHE;\n        wsdl.onReady(callback);\n      }\n    });\n  } else {\n    debug('Reading url: %s', uri);\n    var httpClient = options.httpClient || new http_1.HttpClient(options);\n    httpClient.request(uri, null\n    /* options */\n    , function (err, response, definition) {\n      if (err) {\n        callback(err);\n      } else if (response && response.status === 200) {\n        wsdl = new WSDL(definition, uri, options);\n        WSDL_CACHE[uri] = wsdl;\n        wsdl.WSDL_CACHE = WSDL_CACHE;\n        wsdl.onReady(callback);\n      } else {\n        callback(new Error('Invalid WSDL URL: ' + uri + '\\n\\n\\r Code: ' + response.status + '\\n\\n\\r Response Body: ' + response.data));\n      }\n    }, request_headers, request_options);\n  }\n\n  return wsdl;\n}\n\nexports.open_wsdl = open_wsdl;","map":{"version":3,"names":["exports","__esModule","open_wsdl","WSDL","assert_1","require","debugBuilder","fs","_","path","sax","stripBom","url","http_1","nscontext_1","utils_1","elements","debug","XSI_URI","trimLeft","trimRight","trim","text","replace","deepMerge","destination","source","mergeWith","a","b","Array","isArray","concat","undefined","appendColon","ns","charAt","length","noColonNameSpace","substring","definition","uri","options","_this","ignoredNamespaces","ignoreBaseNameSpaces","valueKey","xmlKey","fromFunc","callback","_includesWsdl","WSDL_CACHE","_initializeOptions","_fromXML","_fromServices","Error","process","nextTick","call","e","processIncludes","err","name","definitions","deleteFixedAttrs","services","postProcess","complexTypes","bindings","bindingName","binding","style","methods","topEls","topElements","methodName","input","inputName","$name","outputName","output","xmlnsInEnvelope","_xmlnsMap","prototype","onReady","schemas","includes","schema","_processNextInclude","describeServices","name_1","service","description","toXML","xml","getSaxStream","saxStream","createStream","pipe","xmlToObject","p","parser","objectName","root","Envelope","Header","Security","UsernameToken","Username","Password","Body","Fault","faultcode","faultstring","detail","stack","object","xmlns","refs","id","onopentag","node","nsName","attrs","attributes","splitQName","attributeName","top","topSchema","elementAttributes","hasNonXmlnsAttribute","hasNilAttribute","obj","originalName","message","messages","isInput","isOutput","test","portTypes","portTypeNames","Object","keys","portType","returnFault","onerror","href","substr","hrefs","push","par","key","res","prefix","toLowerCase","attributesKey","xsiTypeSchema","xsiType","type","typeURI","TNS_PREFIX","typeDef","findSchemaObject","nil","onclosetag","cur","pop","topObject","split","handleNilAsNull","isPlainObject","oncdata","originalText","top_1","value","ontext","resume","statusCode","customDeserializer","parseInt","Number","Date","preserveWhitespace","on","r","finish","write","close","n","ref","_i","_a","assign","body","code","$value","string","error","JSON","stringify","nsURI","qname","def","indexOf","types","objectToDocumentXML","params","nsPrefix","_xml","args","parameterTypeObj","objectToXML","objectToRpcXML","isParts","parts","defs","nsAttrName","findPrefix","join","hasOwnProperty","prefixedKey","xmlEscape","isIgnoredNameSpace","filterOutIgnoredNameSpace","namespace","isFirst","xmlnsAttr","schemaObject","nsContext","parentNsPrefix","parent","current","soapHeader","qualified","$elementFormDefault","prefixNamespace","xmlnsAttrib","overrideRootElement","xmlnsAttributes","forEach","attribute","NamespaceContext","declareNamespace","pushContext","i","nonSubNameSpace","emptyNonSubNameSpaceForArray","nameWithNsRegex","exec","item","arrayAttr","processAttributes","correctOuterNsPrefix","openingTagParts","useEmptyTag","namespaceArrayElements","currentChildXmlnsAttrib","popContext","child","attr","emptyNonSubNameSpace","childSchemaObject","findChildSchemaObject","$type","$ref","childNsPrefix","childName","childNsURI","childXmlnsAttrib","elementQName","$targetNamespace","registerNamespace","unqualified","targetNamespace","$form","resolvedChildSchemaObject","typeQName","typePrefix","addNamespace","findSchemaType","$baseNameSpace","xsi_type","completeChildParamTypeObject","escapeXML","attrObj","k","v","name_2","backtrace","found","$lookupTypes","typeObj","typeInfo","$base","children","baseInfo","baseDef","baseQName","childNameSpace","schemaXmlns","foundBase","_originalIgnoredNamespaces","namespaces","override","wsdl_headers","wsdl_options","httpClient","request","forceSoap12Headers","include","shift","includePath","location","isFixed","fixedPath","resolve","dirname","parse","base","overrideImportLocation","open_wsdl_recursive","wsdl","DefinitionsElement","SchemaElement","merge","_parse","schemaAttrs","startElement","strict","Element","TypesElement","addChild","ok","endElement","descriptions","str","alias","p2","p3","fromCache","request_headers","request_options","readFile","HttpClient","response","status","data"],"sources":["C:/Users/ayber/node_modules/soap/lib/wsdl/index.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\n * MIT Licensed\n *\n */\n/*jshint proto:true*/\nexports.__esModule = true;\nexports.open_wsdl = exports.WSDL = void 0;\nvar assert_1 = require(\"assert\");\nvar debugBuilder = require(\"debug\");\nvar fs = require(\"fs\");\nvar _ = require(\"lodash\");\nvar path = require(\"path\");\nvar sax = require(\"sax\");\nvar stripBom = require(\"strip-bom\");\nvar url = require(\"url\");\nvar http_1 = require(\"../http\");\nvar nscontext_1 = require(\"../nscontext\");\nvar utils_1 = require(\"../utils\");\nvar elements = require(\"./elements\");\nvar debug = debugBuilder('node-soap');\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar trimLeft = /^[\\s\\xA0]+/;\nvar trimRight = /[\\s\\xA0]+$/;\nfunction trim(text) {\n    return text.replace(trimLeft, '').replace(trimRight, '');\n}\nfunction deepMerge(destination, source) {\n    return _.mergeWith(destination, source, function (a, b) {\n        return Array.isArray(a) ? a.concat(b) : undefined;\n    });\n}\nfunction appendColon(ns) {\n    return (ns && ns.charAt(ns.length - 1) !== ':') ? ns + ':' : ns;\n}\nfunction noColonNameSpace(ns) {\n    return (ns && ns.charAt(ns.length - 1) === ':') ? ns.substring(0, ns.length - 1) : ns;\n}\nvar WSDL = /** @class */ (function () {\n    function WSDL(definition, uri, options) {\n        var _this = this;\n        this.ignoredNamespaces = ['tns', 'targetNamespace', 'typedNamespace'];\n        this.ignoreBaseNameSpaces = false;\n        this.valueKey = '$value';\n        this.xmlKey = '$xml';\n        var fromFunc;\n        this.uri = uri;\n        this.callback = function () { };\n        this._includesWsdl = [];\n        // initialize WSDL cache\n        this.WSDL_CACHE = {};\n        if (options && options.WSDL_CACHE) {\n            this.WSDL_CACHE = options.WSDL_CACHE;\n        }\n        this._initializeOptions(options);\n        if (typeof definition === 'string') {\n            definition = stripBom(definition);\n            fromFunc = this._fromXML;\n        }\n        else if (typeof definition === 'object') {\n            fromFunc = this._fromServices;\n        }\n        else {\n            throw new Error('WSDL constructor takes either an XML string or service definition');\n        }\n        process.nextTick(function () {\n            try {\n                fromFunc.call(_this, definition);\n            }\n            catch (e) {\n                return _this.callback(e);\n            }\n            _this.processIncludes(function (err) {\n                var name;\n                if (err) {\n                    return _this.callback(err);\n                }\n                try {\n                    _this.definitions.deleteFixedAttrs();\n                    var services = _this.services = _this.definitions.services;\n                    if (services) {\n                        for (name in services) {\n                            services[name].postProcess(_this.definitions);\n                        }\n                    }\n                    var complexTypes = _this.definitions.complexTypes;\n                    if (complexTypes) {\n                        for (name in complexTypes) {\n                            complexTypes[name].deleteFixedAttrs();\n                        }\n                    }\n                    // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\n                    var bindings = _this.definitions.bindings;\n                    for (var bindingName in bindings) {\n                        var binding = bindings[bindingName];\n                        if (typeof binding.style === 'undefined') {\n                            binding.style = 'document';\n                        }\n                        var methods = binding.methods;\n                        var topEls = binding.topElements = {};\n                        for (var methodName in methods) {\n                            if ((methods[methodName].style || binding.style) !== 'document') {\n                                continue;\n                            }\n                            if (methods[methodName].input) {\n                                var inputName = methods[methodName].input.$name;\n                                var outputName = '';\n                                if (methods[methodName].output) {\n                                    outputName = methods[methodName].output.$name;\n                                }\n                                topEls[inputName] = { methodName: methodName, outputName: outputName };\n                            }\n                        }\n                    }\n                    // prepare soap envelope xmlns definition string\n                    _this.xmlnsInEnvelope = _this._xmlnsMap();\n                    _this.callback(err, _this);\n                }\n                catch (e) {\n                    _this.callback(e);\n                }\n            });\n        });\n    }\n    WSDL.prototype.onReady = function (callback) {\n        if (callback) {\n            this.callback = callback;\n        }\n    };\n    WSDL.prototype.processIncludes = function (callback) {\n        var schemas = this.definitions.schemas;\n        var includes = [];\n        for (var ns in schemas) {\n            var schema = schemas[ns];\n            includes = includes.concat(schema.includes || []);\n        }\n        this._processNextInclude(includes, callback);\n    };\n    WSDL.prototype.describeServices = function () {\n        var services = {};\n        for (var name_1 in this.services) {\n            var service = this.services[name_1];\n            services[name_1] = service.description(this.definitions);\n        }\n        return services;\n    };\n    WSDL.prototype.toXML = function () {\n        return this.xml || '';\n    };\n    WSDL.prototype.getSaxStream = function (xml) {\n        var saxStream = sax.createStream(true, null);\n        xml.pipe(saxStream);\n        return saxStream;\n    };\n    WSDL.prototype.xmlToObject = function (xml, callback) {\n        var _this = this;\n        var p = typeof callback === 'function' ? {} : sax.parser(true, null);\n        var objectName = null;\n        var root = {};\n        var schema = {\n            Envelope: {\n                Header: {\n                    Security: {\n                        UsernameToken: {\n                            Username: 'string',\n                            Password: 'string'\n                        }\n                    }\n                },\n                Body: {\n                    Fault: {\n                        faultcode: 'string',\n                        faultstring: 'string',\n                        detail: 'string'\n                    }\n                }\n            }\n        };\n        var stack = [{ name: null, object: root, schema: schema }];\n        var xmlns = {};\n        var refs = {};\n        var id; // {id:{hrefs:[],obj:}, ...}\n        p.onopentag = function (node) {\n            var nsName = node.name;\n            var attrs = node.attributes;\n            var name = utils_1.splitQName(nsName).name;\n            var attributeName;\n            var top = stack[stack.length - 1];\n            var topSchema = top.schema;\n            var elementAttributes = {};\n            var hasNonXmlnsAttribute = false;\n            var hasNilAttribute = false;\n            var obj = {};\n            var originalName = name;\n            if (!objectName && top.name === 'Body' && name !== 'Fault') {\n                var message = _this.definitions.messages[name];\n                // Support RPC/literal messages where response body contains one element named\n                // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names\n                if (!message) {\n                    try {\n                        // Determine if this is request or response\n                        var isInput = false;\n                        var isOutput = false;\n                        if ((/Response$/).test(name)) {\n                            isOutput = true;\n                            name = name.replace(/Response$/, '');\n                        }\n                        else if ((/Request$/).test(name)) {\n                            isInput = true;\n                            name = name.replace(/Request$/, '');\n                        }\n                        else if ((/Solicit$/).test(name)) {\n                            isInput = true;\n                            name = name.replace(/Solicit$/, '');\n                        }\n                        // Look up the appropriate message as given in the portType's operations\n                        var portTypes = _this.definitions.portTypes;\n                        var portTypeNames = Object.keys(portTypes);\n                        // Currently this supports only one portType definition.\n                        var portType = portTypes[portTypeNames[0]];\n                        if (isInput) {\n                            name = portType.methods[name].input.$name;\n                        }\n                        else {\n                            name = portType.methods[name].output.$name;\n                        }\n                        message = _this.definitions.messages[name];\n                        // 'cache' this alias to speed future lookups\n                        _this.definitions.messages[originalName] = _this.definitions.messages[name];\n                    }\n                    catch (e) {\n                        if (_this.options.returnFault) {\n                            p.onerror(e);\n                        }\n                    }\n                }\n                topSchema = message.description(_this.definitions);\n                objectName = originalName;\n            }\n            if (attrs.href) {\n                id = attrs.href.substr(1);\n                if (!refs[id]) {\n                    refs[id] = { hrefs: [], obj: null };\n                }\n                refs[id].hrefs.push({ par: top.object, key: name, obj: obj });\n            }\n            if (id = attrs.id) {\n                if (!refs[id]) {\n                    refs[id] = { hrefs: [], obj: null };\n                }\n            }\n            // Handle element attributes\n            for (attributeName in attrs) {\n                if (/^xmlns:|^xmlns$/.test(attributeName)) {\n                    xmlns[utils_1.splitQName(attributeName).name] = attrs[attributeName];\n                    continue;\n                }\n                hasNonXmlnsAttribute = true;\n                elementAttributes[attributeName] = attrs[attributeName];\n            }\n            for (attributeName in elementAttributes) {\n                var res = utils_1.splitQName(attributeName);\n                if (res.name === 'nil' && xmlns[res.prefix] === XSI_URI && elementAttributes[attributeName] &&\n                    (elementAttributes[attributeName].toLowerCase() === 'true' || elementAttributes[attributeName] === '1')) {\n                    hasNilAttribute = true;\n                    break;\n                }\n            }\n            if (hasNonXmlnsAttribute) {\n                obj[_this.options.attributesKey] = elementAttributes;\n            }\n            // Pick up the schema for the type specified in element's xsi:type attribute.\n            var xsiTypeSchema;\n            var xsiType;\n            for (var prefix in xmlns) {\n                if (xmlns[prefix] === XSI_URI && (prefix + \":type\" in elementAttributes)) {\n                    xsiType = elementAttributes[prefix + \":type\"];\n                    break;\n                }\n            }\n            if (xsiType) {\n                var type = utils_1.splitQName(xsiType);\n                var typeURI = void 0;\n                if (type.prefix === utils_1.TNS_PREFIX) {\n                    // In case of xsi:type = \"MyType\"\n                    typeURI = xmlns[type.prefix] || xmlns.xmlns;\n                }\n                else {\n                    typeURI = xmlns[type.prefix];\n                }\n                var typeDef = _this.findSchemaObject(typeURI, type.name);\n                if (typeDef) {\n                    xsiTypeSchema = typeDef.description(_this.definitions);\n                }\n            }\n            if (topSchema && topSchema[name + '[]']) {\n                name = name + '[]';\n            }\n            stack.push({ name: originalName, object: obj, schema: (xsiTypeSchema || (topSchema && topSchema[name])), id: attrs.id, nil: hasNilAttribute });\n        };\n        p.onclosetag = function (nsName) {\n            var cur = stack.pop();\n            var obj = cur.object;\n            var top = stack[stack.length - 1];\n            var topObject = top.object;\n            var topSchema = top.schema;\n            var name = utils_1.splitQName(nsName).name;\n            if (typeof cur.schema === 'string' && (cur.schema === 'string' || cur.schema.split(':')[1] === 'string')) {\n                if (typeof obj === 'object' && Object.keys(obj).length === 0) {\n                    obj = cur.object = '';\n                }\n            }\n            if (cur.nil === true) {\n                if (_this.options.handleNilAsNull) {\n                    obj = null;\n                }\n                else {\n                    return;\n                }\n            }\n            if (_.isPlainObject(obj) && !Object.keys(obj).length) {\n                obj = null;\n            }\n            if (topSchema && topSchema[name + '[]']) {\n                if (!topObject[name]) {\n                    topObject[name] = [];\n                }\n                topObject[name].push(obj);\n            }\n            else if (name in topObject) {\n                if (!Array.isArray(topObject[name])) {\n                    topObject[name] = [topObject[name]];\n                }\n                topObject[name].push(obj);\n            }\n            else {\n                topObject[name] = obj;\n            }\n            if (cur.id) {\n                refs[cur.id].obj = obj;\n            }\n        };\n        p.oncdata = function (text) {\n            var originalText = text;\n            text = trim(text);\n            if (!text.length) {\n                return;\n            }\n            if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\n                var top_1 = stack[stack.length - 1];\n                var value = _this.xmlToObject(text);\n                if (top_1.object[_this.options.attributesKey]) {\n                    top_1.object[_this.options.valueKey] = value;\n                }\n                else {\n                    top_1.object = value;\n                }\n            }\n            else {\n                p.ontext(originalText);\n            }\n        };\n        p.onerror = function (e) {\n            p.resume();\n            throw {\n                Fault: {\n                    faultcode: 500,\n                    faultstring: 'Invalid XML',\n                    detail: new Error(e).message,\n                    statusCode: 500\n                }\n            };\n        };\n        p.ontext = function (text) {\n            var originalText = text;\n            text = trim(text);\n            if (!text.length) {\n                return;\n            }\n            var top = stack[stack.length - 1];\n            var name = utils_1.splitQName(top.schema).name;\n            var value;\n            if (_this.options && _this.options.customDeserializer && _this.options.customDeserializer[name]) {\n                value = _this.options.customDeserializer[name](text, top);\n            }\n            else {\n                if (name === 'int' || name === 'integer' || name === 'short' || name === 'long') {\n                    value = parseInt(text, 10);\n                }\n                else if (name === 'double' || name === 'float' || name === 'decimal') {\n                    value = Number(text);\n                }\n                else if (name === 'bool' || name === 'boolean') {\n                    value = text.toLowerCase() === 'true' || text === '1';\n                }\n                else if (name === 'dateTime' || name === 'date') {\n                    value = new Date(text);\n                }\n                else {\n                    if (_this.options.preserveWhitespace) {\n                        text = originalText;\n                    }\n                    // handle string or other types\n                    if (typeof top.object !== 'string') {\n                        value = text;\n                    }\n                    else {\n                        value = top.object + text;\n                    }\n                }\n            }\n            if (top.object[_this.options.attributesKey]) {\n                top.object[_this.options.valueKey] = value;\n            }\n            else {\n                top.object = value;\n            }\n        };\n        if (typeof callback === 'function') {\n            // we be streaming\n            var saxStream = sax.createStream(true, null);\n            saxStream.on('opentag', p.onopentag);\n            saxStream.on('closetag', p.onclosetag);\n            saxStream.on('cdata', p.oncdata);\n            saxStream.on('text', p.ontext);\n            xml.pipe(saxStream)\n                .on('error', function (err) {\n                callback(err);\n            })\n                .on('end', function () {\n                var r;\n                try {\n                    r = finish();\n                }\n                catch (e) {\n                    return callback(e);\n                }\n                callback(null, r);\n            });\n            return;\n        }\n        p.write(xml).close();\n        return finish();\n        function finish() {\n            // MultiRef support: merge objects instead of replacing\n            for (var n in refs) {\n                var ref = refs[n];\n                for (var _i = 0, _a = ref.hrefs; _i < _a.length; _i++) {\n                    var href = _a[_i];\n                    Object.assign(href.obj, ref.obj);\n                }\n            }\n            if (root.Envelope) {\n                var body = root.Envelope.Body;\n                if (body && body.Fault) {\n                    var code = body.Fault.faultcode && body.Fault.faultcode.$value;\n                    var string = body.Fault.faultstring && body.Fault.faultstring.$value;\n                    var detail = body.Fault.detail && body.Fault.detail.$value;\n                    code = code || body.Fault.faultcode;\n                    string = string || body.Fault.faultstring;\n                    detail = detail || body.Fault.detail;\n                    var error = new Error(code + ': ' + string + (detail ? ': ' + JSON.stringify(detail) : ''));\n                    error.root = root;\n                    throw error;\n                }\n                return root.Envelope;\n            }\n            return root;\n        }\n    };\n    /**\n     * Look up a XSD type or element by namespace URI and name\n     * @param {String} nsURI Namespace URI\n     * @param {String} qname Local or qualified name\n     * @returns {*} The XSD type/element definition\n     */\n    WSDL.prototype.findSchemaObject = function (nsURI, qname) {\n        if (!nsURI || !qname) {\n            return null;\n        }\n        var def = null;\n        if (this.definitions.schemas) {\n            var schema = this.definitions.schemas[nsURI];\n            if (schema) {\n                if (qname.indexOf(':') !== -1) {\n                    qname = qname.substring(qname.indexOf(':') + 1, qname.length);\n                }\n                // if the client passed an input element which has a `$lookupType` property instead of `$type`\n                // the `def` is found in `schema.elements`.\n                def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];\n            }\n        }\n        return def;\n    };\n    /**\n     * Create document style xml string from the parameters\n     * @param {String} name\n     * @param {*} params\n     * @param {String} nsPrefix\n     * @param {String} nsURI\n     * @param {String} type\n     */\n    WSDL.prototype.objectToDocumentXML = function (name, params, nsPrefix, nsURI, type) {\n        // If user supplies XML already, just use that.  XML Declaration should not be present.\n        if (params && params._xml) {\n            return params._xml;\n        }\n        var args = {};\n        args[name] = params;\n        var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;\n        return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);\n    };\n    /**\n     * Create RPC style xml string from the parameters\n     * @param {String} name\n     * @param {*} params\n     * @param {String} nsPrefix\n     * @param {String} nsURI\n     * @returns {string}\n     */\n    WSDL.prototype.objectToRpcXML = function (name, params, nsPrefix, nsURI, isParts) {\n        var parts = [];\n        var defs = this.definitions;\n        var nsAttrName = '_xmlns';\n        nsPrefix = nsPrefix || utils_1.findPrefix(defs.xmlns, nsURI);\n        nsURI = nsURI || defs.xmlns[nsPrefix];\n        nsPrefix = nsPrefix === utils_1.TNS_PREFIX ? '' : (nsPrefix + ':');\n        parts.push(['<', nsPrefix, name, '>'].join(''));\n        for (var key in params) {\n            if (!params.hasOwnProperty(key)) {\n                continue;\n            }\n            if (key !== nsAttrName) {\n                var value = params[key];\n                var prefixedKey = (isParts ? '' : nsPrefix) + key;\n                var attributes = [];\n                if (typeof value === 'object' && value.hasOwnProperty(this.options.attributesKey)) {\n                    var attrs = value[this.options.attributesKey];\n                    for (var n in attrs) {\n                        attributes.push(' ' + n + '=' + '\"' + attrs[n] + '\"');\n                    }\n                }\n                parts.push(['<', prefixedKey].concat(attributes).concat('>').join(''));\n                parts.push((typeof value === 'object') ? this.objectToXML(value, key, nsPrefix, nsURI) : utils_1.xmlEscape(value));\n                parts.push(['</', prefixedKey, '>'].join(''));\n            }\n        }\n        parts.push(['</', nsPrefix, name, '>'].join(''));\n        return parts.join('');\n    };\n    WSDL.prototype.isIgnoredNameSpace = function (ns) {\n        return this.options.ignoredNamespaces.indexOf(ns) > -1;\n    };\n    WSDL.prototype.filterOutIgnoredNameSpace = function (ns) {\n        var namespace = noColonNameSpace(ns);\n        return this.isIgnoredNameSpace(namespace) ? '' : namespace;\n    };\n    /**\n     * Convert an object to XML.  This is a recursive method as it calls itself.\n     *\n     * @param {Object} obj the object to convert.\n     * @param {String} name the name of the element (if the object being traversed is\n     * an element).\n     * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.\n     * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.\n     * @param {Boolean} isFirst whether or not this is the first item being traversed.\n     * @param {?} xmlnsAttr\n     * @param {?} parameterTypeObject\n     * @param {NamespaceContext} nsContext Namespace context\n     */\n    WSDL.prototype.objectToXML = function (obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {\n        var schema = this.definitions.schemas[nsURI];\n        var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;\n        if (typeof parentNsPrefix !== 'undefined') {\n            // we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string\n            nsPrefix = nsPrefix.current;\n        }\n        parentNsPrefix = noColonNameSpace(parentNsPrefix);\n        if (this.isIgnoredNameSpace(parentNsPrefix)) {\n            parentNsPrefix = '';\n        }\n        var soapHeader = !schema;\n        var qualified = schema && schema.$elementFormDefault === 'qualified';\n        var parts = [];\n        var prefixNamespace = (nsPrefix || qualified) && nsPrefix !== utils_1.TNS_PREFIX;\n        var xmlnsAttrib = '';\n        if (nsURI && isFirst) {\n            if (this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes) {\n                this.options.overrideRootElement.xmlnsAttributes.forEach(function (attribute) {\n                    xmlnsAttrib += ' ' + attribute.name + '=\"' + attribute.value + '\"';\n                });\n            }\n            else {\n                if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {\n                    // resolve the prefix namespace\n                    xmlnsAttrib += ' xmlns:' + nsPrefix + '=\"' + nsURI + '\"';\n                }\n                // only add default namespace if the schema elementFormDefault is qualified\n                if (qualified || soapHeader) {\n                    xmlnsAttrib += ' xmlns=\"' + nsURI + '\"';\n                }\n            }\n        }\n        if (!nsContext) {\n            nsContext = new nscontext_1.NamespaceContext();\n            nsContext.declareNamespace(nsPrefix, nsURI);\n        }\n        else {\n            nsContext.pushContext();\n        }\n        // explicitly use xmlns attribute if available\n        if (xmlnsAttr && !(this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes)) {\n            xmlnsAttrib = xmlnsAttr;\n        }\n        var ns = '';\n        if (this.options.overrideRootElement && isFirst) {\n            ns = this.options.overrideRootElement.namespace;\n        }\n        else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {\n            ns = nsPrefix;\n        }\n        var i;\n        var n;\n        // start building out XML string.\n        if (Array.isArray(obj)) {\n            var nonSubNameSpace = '';\n            var emptyNonSubNameSpaceForArray = false;\n            var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n            if (nameWithNsRegex) {\n                nonSubNameSpace = nameWithNsRegex[1];\n                name = nameWithNsRegex[2];\n            }\n            else if (name[0] === ':') {\n                emptyNonSubNameSpaceForArray = true;\n                name = name.substr(1);\n            }\n            for (i = 0, n = obj.length; i < n; i++) {\n                var item = obj[i];\n                var arrayAttr = this.processAttributes(item, nsContext);\n                var correctOuterNsPrefix = nonSubNameSpace || parentNsPrefix || ns; // using the parent namespace prefix if given\n                var body = this.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n                var openingTagParts = ['<', name, arrayAttr, xmlnsAttrib];\n                if (!emptyNonSubNameSpaceForArray) {\n                    openingTagParts = ['<', appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib];\n                }\n                if (body === '' && this.options.useEmptyTag) {\n                    // Use empty (self-closing) tags if no contents\n                    openingTagParts.push(' />');\n                    parts.push(openingTagParts.join(''));\n                }\n                else {\n                    openingTagParts.push('>');\n                    if (this.options.namespaceArrayElements || i === 0) {\n                        parts.push(openingTagParts.join(''));\n                    }\n                    parts.push(body);\n                    if (this.options.namespaceArrayElements || i === n - 1) {\n                        if (emptyNonSubNameSpaceForArray) {\n                            parts.push(['</', name, '>'].join(''));\n                        }\n                        else {\n                            parts.push(['</', appendColon(correctOuterNsPrefix), name, '>'].join(''));\n                        }\n                    }\n                }\n            }\n        }\n        else if (typeof obj === 'object') {\n            var currentChildXmlnsAttrib = '';\n            for (name in obj) {\n                // Happens when Object.create(null) is used, it will not inherit the Object prototype\n                if (!obj.hasOwnProperty) {\n                    obj = Object.assign({}, obj);\n                }\n                if (!obj.hasOwnProperty(name)) {\n                    continue;\n                }\n                // don't process attributes as element\n                if (name === this.options.attributesKey) {\n                    continue;\n                }\n                // Its the value of a xml object. Return it directly.\n                if (name === this.options.xmlKey) {\n                    nsContext.popContext();\n                    return obj[name];\n                }\n                // Its the value of an item. Return it directly.\n                if (name === this.options.valueKey) {\n                    nsContext.popContext();\n                    return utils_1.xmlEscape(obj[name]);\n                }\n                var child = obj[name];\n                if (typeof child === 'undefined') {\n                    continue;\n                }\n                var attr = this.processAttributes(child, nsContext);\n                var value = '';\n                var nonSubNameSpace = '';\n                var emptyNonSubNameSpace = false;\n                var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n                if (nameWithNsRegex) {\n                    nonSubNameSpace = nameWithNsRegex[1] + ':';\n                    name = nameWithNsRegex[2];\n                }\n                else if (name[0] === ':') {\n                    emptyNonSubNameSpace = true;\n                    name = name.substr(1);\n                }\n                if (isFirst) {\n                    value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n                }\n                else {\n                    if (this.definitions.schemas) {\n                        if (schema) {\n                            var childSchemaObject = this.findChildSchemaObject(schemaObject, name);\n                            // find sub namespace if not a primitive\n                            if (childSchemaObject &&\n                                ((childSchemaObject.$type && (childSchemaObject.$type.indexOf('xsd:') === -1)) ||\n                                    childSchemaObject.$ref || childSchemaObject.$name)) {\n                                /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.\n                                 This is because in some services the child nodes do not need the baseNameSpace.\n                                 */\n                                var childNsPrefix = '';\n                                var childName = '';\n                                var childNsURI = void 0;\n                                var childXmlnsAttrib = '';\n                                var elementQName = childSchemaObject.$ref || childSchemaObject.$name;\n                                if (elementQName) {\n                                    elementQName = utils_1.splitQName(elementQName);\n                                    childName = elementQName.name;\n                                    if (elementQName.prefix === utils_1.TNS_PREFIX) {\n                                        // Local element\n                                        childNsURI = childSchemaObject.$targetNamespace;\n                                        childNsPrefix = nsContext.registerNamespace(childNsURI);\n                                        if (this.isIgnoredNameSpace(childNsPrefix)) {\n                                            childNsPrefix = nsPrefix;\n                                        }\n                                    }\n                                    else {\n                                        childNsPrefix = elementQName.prefix;\n                                        if (this.isIgnoredNameSpace(childNsPrefix)) {\n                                            childNsPrefix = nsPrefix;\n                                        }\n                                        childNsURI = schema.xmlns[childNsPrefix] || this.definitions.xmlns[childNsPrefix];\n                                    }\n                                    var unqualified = false;\n                                    // Check qualification form for local elements\n                                    if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {\n                                        if (childSchemaObject.$form === 'unqualified') {\n                                            unqualified = true;\n                                        }\n                                        else if (childSchemaObject.$form === 'qualified') {\n                                            unqualified = false;\n                                        }\n                                        else {\n                                            unqualified = schema.$elementFormDefault !== 'qualified';\n                                        }\n                                    }\n                                    if (unqualified) {\n                                        childNsPrefix = '';\n                                    }\n                                    if (childNsURI && childNsPrefix) {\n                                        if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {\n                                            childXmlnsAttrib = ' xmlns:' + childNsPrefix + '=\"' + childNsURI + '\"';\n                                            if (!xmlnsAttrib.includes(childNsPrefix)) {\n                                                currentChildXmlnsAttrib = childXmlnsAttrib;\n                                                xmlnsAttrib += childXmlnsAttrib;\n                                            }\n                                        }\n                                    }\n                                }\n                                var resolvedChildSchemaObject = void 0;\n                                if (childSchemaObject.$type) {\n                                    var typeQName = utils_1.splitQName(childSchemaObject.$type);\n                                    var typePrefix = typeQName.prefix;\n                                    var typeURI = schema.xmlns[typePrefix] || this.definitions.xmlns[typePrefix];\n                                    childNsURI = typeURI;\n                                    if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== utils_1.TNS_PREFIX) {\n                                        // Add the prefix/namespace mapping, but not declare it\n                                        nsContext.addNamespace(typePrefix, typeURI);\n                                    }\n                                    resolvedChildSchemaObject =\n                                        this.findSchemaType(typeQName.name, typeURI) || childSchemaObject;\n                                }\n                                else {\n                                    resolvedChildSchemaObject =\n                                        this.findSchemaObject(childNsURI, childName) || childSchemaObject;\n                                }\n                                if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {\n                                    childNsPrefix = nsPrefix;\n                                    childNsURI = nsURI;\n                                }\n                                if (this.options.ignoreBaseNameSpaces) {\n                                    childNsPrefix = '';\n                                    childNsURI = '';\n                                }\n                                ns = childNsPrefix;\n                                if (Array.isArray(child)) {\n                                    // for arrays, we need to remember the current namespace\n                                    childNsPrefix = {\n                                        current: childNsPrefix,\n                                        parent: ns\n                                    };\n                                    childXmlnsAttrib = childXmlnsAttrib && childXmlnsAttrib.length ? childXmlnsAttrib : currentChildXmlnsAttrib;\n                                }\n                                else {\n                                    // parent (array) already got the namespace\n                                    childXmlnsAttrib = null;\n                                }\n                                value = this.objectToXML(child, name, childNsPrefix, childNsURI, false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);\n                            }\n                            else if (obj[this.options.attributesKey] && obj[this.options.attributesKey].xsi_type) {\n                                // if parent object has complex type defined and child not found in parent\n                                var completeChildParamTypeObject = this.findChildSchemaObject(obj[this.options.attributesKey].xsi_type.type, obj[this.options.attributesKey].xsi_type.xmlns);\n                                nonSubNameSpace = obj[this.options.attributesKey].xsi_type.prefix;\n                                nsContext.addNamespace(obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns);\n                                value = this.objectToXML(child, name, obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);\n                            }\n                            else {\n                                if (Array.isArray(child)) {\n                                    if (emptyNonSubNameSpace) {\n                                        name = ':' + name;\n                                    }\n                                    else {\n                                        name = nonSubNameSpace + name;\n                                    }\n                                }\n                                value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n                            }\n                        }\n                        else {\n                            value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n                        }\n                    }\n                }\n                ns = noColonNameSpace(ns);\n                if (prefixNamespace && !qualified && isFirst && !this.options.overrideRootElement) {\n                    ns = nsPrefix;\n                }\n                else if (this.isIgnoredNameSpace(ns)) {\n                    ns = '';\n                }\n                var useEmptyTag = !value && this.options.useEmptyTag;\n                if (!Array.isArray(child)) {\n                    // start tag\n                    parts.push(['<', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, attr, xmlnsAttrib,\n                        (child === null ? ' xsi:nil=\"true\"' : ''),\n                        useEmptyTag ? ' />' : '>',\n                    ].join(''));\n                }\n                if (!useEmptyTag) {\n                    parts.push(value);\n                    if (!Array.isArray(child)) {\n                        // end tag\n                        parts.push(['</', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, '>'].join(''));\n                    }\n                }\n            }\n        }\n        else if (obj !== undefined) {\n            parts.push((this.options.escapeXML) ? utils_1.xmlEscape(obj) : obj);\n        }\n        nsContext.popContext();\n        return parts.join('');\n    };\n    WSDL.prototype.processAttributes = function (child, nsContext) {\n        var attr = '';\n        if (child === null || child === undefined) {\n            child = [];\n        }\n        var attrObj = child[this.options.attributesKey] || {};\n        if (attrObj && attrObj.xsi_type) {\n            var xsiType = attrObj.xsi_type;\n            var prefix = xsiType.prefix || xsiType.namespace;\n            if (xsiType.xmlns) {\n                // Generate a new namespace for complex extension if one not provided\n                if (!prefix) {\n                    prefix = nsContext.registerNamespace(xsiType.xmlns);\n                }\n                else {\n                    nsContext.declareNamespace(prefix, xsiType.xmlns);\n                }\n                xsiType.prefix = prefix;\n            }\n        }\n        Object.keys(attrObj).forEach(function (k) {\n            var v = attrObj[k];\n            if (k === 'xsi_type') {\n                var name_2 = v.type;\n                if (v.prefix) {\n                    name_2 = v.prefix + \":\" + name_2;\n                }\n                attr += \" xsi:type=\\\"\" + name_2 + \"\\\"\";\n                if (v.xmlns) {\n                    attr += \" xmlns:\" + v.prefix + \"=\\\"\" + v.xmlns + \"\\\"\";\n                }\n            }\n            else {\n                attr += \" \" + k + \"=\\\"\" + utils_1.xmlEscape(v) + \"\\\"\";\n            }\n        });\n        return attr;\n    };\n    /**\n     * Look up a schema type definition\n     * @param name\n     * @param nsURI\n     * @returns {*}\n     */\n    WSDL.prototype.findSchemaType = function (name, nsURI) {\n        if (!this.definitions.schemas || !name || !nsURI) {\n            return null;\n        }\n        var schema = this.definitions.schemas[nsURI];\n        if (!schema || !schema.complexTypes) {\n            return null;\n        }\n        return schema.complexTypes[name];\n    };\n    WSDL.prototype.findChildSchemaObject = function (parameterTypeObj, childName, backtrace) {\n        if (!parameterTypeObj || !childName) {\n            return null;\n        }\n        if (!backtrace) {\n            backtrace = [];\n        }\n        if (backtrace.indexOf(parameterTypeObj) >= 0) {\n            // We've recursed back to ourselves; break.\n            return null;\n        }\n        else {\n            backtrace = backtrace.concat([parameterTypeObj]);\n        }\n        var found = null;\n        var i = 0;\n        var child;\n        var ref;\n        if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {\n            var types = parameterTypeObj.$lookupTypes;\n            for (i = 0; i < types.length; i++) {\n                var typeObj = types[i];\n                if (typeObj.$name === childName) {\n                    found = typeObj;\n                    break;\n                }\n            }\n        }\n        var object = parameterTypeObj;\n        if (object.$name === childName && object.name === 'element') {\n            return object;\n        }\n        if (object.$ref) {\n            ref = utils_1.splitQName(object.$ref);\n            if (ref.name === childName) {\n                return object;\n            }\n        }\n        var childNsURI;\n        // want to avoid unecessary recursion to improve performance\n        if (object.$type && backtrace.length === 1) {\n            var typeInfo = utils_1.splitQName(object.$type);\n            if (typeInfo.prefix === utils_1.TNS_PREFIX) {\n                childNsURI = parameterTypeObj.$targetNamespace;\n            }\n            else {\n                childNsURI = this.definitions.xmlns[typeInfo.prefix];\n            }\n            var typeDef = this.findSchemaType(typeInfo.name, childNsURI);\n            if (typeDef) {\n                return this.findChildSchemaObject(typeDef, childName, backtrace);\n            }\n        }\n        // handle $base (e.g. for ExtensionElement) like $type\n        if (object.$base && (!Array.isArray(object.children) || !object.children.length)) {\n            var baseInfo = utils_1.splitQName(object.$base);\n            childNsURI = parameterTypeObj.$targetNamespace;\n            if (baseInfo.prefix !== utils_1.TNS_PREFIX) {\n                childNsURI = this.definitions.xmlns[baseInfo.prefix];\n            }\n            var baseDef = this.findSchemaType(baseInfo.name, childNsURI);\n            if (baseDef) {\n                return this.findChildSchemaObject(baseDef, childName, backtrace);\n            }\n        }\n        if (Array.isArray(object.children) && object.children.length > 0) {\n            for (i = 0, child; child = object.children[i]; i++) {\n                found = this.findChildSchemaObject(child, childName, backtrace);\n                if (found) {\n                    break;\n                }\n                if (child.$base) {\n                    var baseQName = utils_1.splitQName(child.$base);\n                    var childNameSpace = baseQName.prefix === utils_1.TNS_PREFIX ? '' : baseQName.prefix;\n                    childNsURI = child.xmlns[baseQName.prefix] || child.schemaXmlns[baseQName.prefix];\n                    var foundBase = this.findSchemaType(baseQName.name, childNsURI);\n                    if (foundBase) {\n                        found = this.findChildSchemaObject(foundBase, childName, backtrace);\n                        if (found) {\n                            found.$baseNameSpace = childNameSpace;\n                            found.$type = childNameSpace + ':' + childName;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (!found && object.$name === childName) {\n            return object;\n        }\n        return found;\n    };\n    WSDL.prototype._initializeOptions = function (options) {\n        this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;\n        this.options = {};\n        var ignoredNamespaces = options ? options.ignoredNamespaces : null;\n        if (ignoredNamespaces &&\n            (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {\n            if (ignoredNamespaces.override) {\n                this.options.ignoredNamespaces = ignoredNamespaces.namespaces;\n            }\n            else {\n                this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);\n            }\n        }\n        else {\n            this.options.ignoredNamespaces = this.ignoredNamespaces;\n        }\n        this.options.valueKey = options.valueKey || this.valueKey;\n        this.options.xmlKey = options.xmlKey || this.xmlKey;\n        if (options.escapeXML !== undefined) {\n            this.options.escapeXML = options.escapeXML;\n        }\n        else {\n            this.options.escapeXML = true;\n        }\n        if (options.returnFault !== undefined) {\n            this.options.returnFault = options.returnFault;\n        }\n        else {\n            this.options.returnFault = false;\n        }\n        this.options.handleNilAsNull = !!options.handleNilAsNull;\n        if (options.namespaceArrayElements !== undefined) {\n            this.options.namespaceArrayElements = options.namespaceArrayElements;\n        }\n        else {\n            this.options.namespaceArrayElements = true;\n        }\n        // Allow any request headers to keep passing through\n        this.options.wsdl_headers = options.wsdl_headers;\n        this.options.wsdl_options = options.wsdl_options;\n        if (options.httpClient) {\n            this.options.httpClient = options.httpClient;\n        }\n        // The supplied request-object should be passed through\n        if (options.request) {\n            this.options.request = options.request;\n        }\n        var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;\n        if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {\n            this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;\n        }\n        else {\n            this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;\n        }\n        // Works only in client\n        this.options.forceSoap12Headers = options.forceSoap12Headers;\n        this.options.customDeserializer = options.customDeserializer;\n        if (options.overrideRootElement !== undefined) {\n            this.options.overrideRootElement = options.overrideRootElement;\n        }\n        this.options.useEmptyTag = !!options.useEmptyTag;\n    };\n    WSDL.prototype._processNextInclude = function (includes, callback) {\n        var _this = this;\n        var include = includes.shift();\n        if (!include) {\n            return callback();\n        }\n        var includePath;\n        if (!/^https?:/i.test(this.uri) && !/^https?:/i.test(include.location)) {\n            var isFixed = (this.options.wsdl_options !== undefined && this.options.wsdl_options.hasOwnProperty('fixedPath')) ? this.options.wsdl_options.fixedPath : false;\n            if (isFixed) {\n                includePath = path.resolve(path.dirname(this.uri), path.parse(include.location).base);\n            }\n            else {\n                includePath = path.resolve(path.dirname(this.uri), include.location);\n            }\n        }\n        else {\n            includePath = url.resolve(this.uri || '', include.location);\n        }\n        if (this.options.wsdl_options !== undefined && typeof this.options.wsdl_options.overrideImportLocation === 'function') {\n            includePath = this.options.wsdl_options.overrideImportLocation(includePath);\n        }\n        var options = Object.assign({}, this.options);\n        // follow supplied ignoredNamespaces option\n        options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;\n        options.WSDL_CACHE = this.WSDL_CACHE;\n        open_wsdl_recursive(includePath, options, function (err, wsdl) {\n            if (err) {\n                return callback(err);\n            }\n            _this._includesWsdl.push(wsdl);\n            if (wsdl.definitions instanceof elements.DefinitionsElement) {\n                _.mergeWith(_this.definitions, wsdl.definitions, function (a, b) {\n                    return (a instanceof elements.SchemaElement) ? a.merge(b) : undefined;\n                });\n            }\n            else {\n                return callback(new Error('wsdl.defintions is not an instance of elements.DefinitionsElement'));\n            }\n            _this._processNextInclude(includes, function (err) {\n                callback(err);\n            });\n        });\n    };\n    WSDL.prototype._parse = function (xml) {\n        var _this = this;\n        var p = sax.parser(true, null);\n        var stack = [];\n        var root = null;\n        var types = null;\n        var schema = null;\n        var schemaAttrs = null;\n        var options = this.options;\n        p.onopentag = function (node) {\n            var nsName = node.name;\n            var attrs = node.attributes;\n            var top = stack[stack.length - 1];\n            var name = utils_1.splitQName(nsName).name;\n            if (name === 'schema') {\n                schemaAttrs = attrs;\n            }\n            if (top) {\n                try {\n                    top.startElement(stack, nsName, attrs, options, schemaAttrs);\n                }\n                catch (e) {\n                    if (_this.options.strict) {\n                        throw e;\n                    }\n                    else {\n                        stack.push(new elements.Element(nsName, attrs, options, schemaAttrs));\n                    }\n                }\n            }\n            else {\n                if (name === 'definitions') {\n                    root = new elements.DefinitionsElement(nsName, attrs, options);\n                    stack.push(root);\n                }\n                else if (name === 'schema') {\n                    // Shim a structure in here to allow the proper objects to be created when merging back.\n                    root = new elements.DefinitionsElement('definitions', {}, {});\n                    types = new elements.TypesElement('types', {}, {});\n                    schema = new elements.SchemaElement(nsName, attrs, options);\n                    types.addChild(schema);\n                    root.addChild(types);\n                    stack.push(schema);\n                }\n                else {\n                    throw new Error('Unexpected root element of WSDL or include');\n                }\n            }\n        };\n        p.onclosetag = function (name) {\n            var top = stack[stack.length - 1];\n            assert_1.ok(top, 'Unmatched close tag: ' + name);\n            top.endElement(stack, name);\n        };\n        p.write(xml).close();\n        return root;\n    };\n    WSDL.prototype._fromXML = function (xml) {\n        this.definitions = this._parse(xml);\n        this.definitions.descriptions = {\n            types: {},\n            elements: {}\n        };\n        this.xml = xml;\n    };\n    WSDL.prototype._fromServices = function (services) {\n    };\n    WSDL.prototype._xmlnsMap = function () {\n        var xmlns = this.definitions.xmlns;\n        var str = '';\n        for (var alias in xmlns) {\n            if (alias === '' || alias === utils_1.TNS_PREFIX) {\n                continue;\n            }\n            var ns = xmlns[alias];\n            switch (ns) {\n                case 'http://xml.apache.org/xml-soap': // apachesoap\n                case 'http://schemas.xmlsoap.org/wsdl/': // wsdl\n                case 'http://schemas.xmlsoap.org/wsdl/soap/': // wsdlsoap\n                case 'http://schemas.xmlsoap.org/wsdl/soap12/': // wsdlsoap12\n                case 'http://schemas.xmlsoap.org/soap/encoding/': // soapenc\n                case 'http://www.w3.org/2001/XMLSchema': // xsd\n                    continue;\n            }\n            if (~ns.indexOf('http://schemas.xmlsoap.org/')) {\n                continue;\n            }\n            if (~ns.indexOf('http://www.w3.org/')) {\n                continue;\n            }\n            if (~ns.indexOf('http://xml.apache.org/')) {\n                continue;\n            }\n            str += ' xmlns:' + alias + '=\"' + ns + '\"';\n        }\n        return str;\n    };\n    return WSDL;\n}());\nexports.WSDL = WSDL;\nfunction open_wsdl_recursive(uri, p2, p3) {\n    var fromCache;\n    var WSDL_CACHE;\n    var options;\n    var callback;\n    if (typeof p2 === 'function') {\n        options = {};\n        callback = p2;\n    }\n    else {\n        options = p2;\n        callback = p3;\n    }\n    WSDL_CACHE = options.WSDL_CACHE;\n    if (fromCache = WSDL_CACHE[uri]) {\n        return callback.call(fromCache, null, fromCache);\n    }\n    return open_wsdl(uri, options, callback);\n}\nfunction open_wsdl(uri, p2, p3) {\n    var options;\n    var callback;\n    if (typeof p2 === 'function') {\n        options = {};\n        callback = p2;\n    }\n    else if (typeof p3 === 'function') {\n        options = p2;\n        callback = p3;\n    }\n    // initialize cache when calling open_wsdl directly\n    var WSDL_CACHE = options.WSDL_CACHE || {};\n    var request_headers = options.wsdl_headers;\n    var request_options = options.wsdl_options;\n    var wsdl;\n    if (!/^https?:/i.test(uri)) {\n        debug('Reading file: %s', uri);\n        fs.readFile(uri, 'utf8', function (err, definition) {\n            if (err) {\n                callback(err);\n            }\n            else {\n                wsdl = new WSDL(definition, uri, options);\n                WSDL_CACHE[uri] = wsdl;\n                wsdl.WSDL_CACHE = WSDL_CACHE;\n                wsdl.onReady(callback);\n            }\n        });\n    }\n    else {\n        debug('Reading url: %s', uri);\n        var httpClient = options.httpClient || new http_1.HttpClient(options);\n        httpClient.request(uri, null /* options */, function (err, response, definition) {\n            if (err) {\n                callback(err);\n            }\n            else if (response && response.status === 200) {\n                wsdl = new WSDL(definition, uri, options);\n                WSDL_CACHE[uri] = wsdl;\n                wsdl.WSDL_CACHE = WSDL_CACHE;\n                wsdl.onReady(callback);\n            }\n            else {\n                callback(new Error('Invalid WSDL URL: ' + uri + '\\n\\n\\r Code: ' + response.status + '\\n\\n\\r Response Body: ' + response.data));\n            }\n        }, request_headers, request_options);\n    }\n    return wsdl;\n}\nexports.open_wsdl = open_wsdl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}